># Q: Do I fix this one the same way?

```py
# 2.2.6 | ID & Protected Columns Registration
print("\n2.2.6 üõ°Ô∏è ID & protected columns registration")

assert "ARTIFACTS_DIR" in globals(), "‚ùå ARTIFACTS_DIR missing."

# Reload type map (in case of intervening modifications)
with open(type_map_path, "r", encoding="utf-8") as f:
    column_type_map = json.load(f)

# Config lists with safe fallbacks
try:
    id_cfg = C("ID_COLUMNS", []) or []
except Exception:
    id_cfg = []

try:
    protected_cfg = C("PROTECTED_COLUMNS", []) or []
except Exception:
    protected_cfg = []

id_from_cfg = {c for c in id_cfg if c in df.columns}
prot_from_cfg = {c for c in protected_cfg if c in df.columns}

# From feature_roles_df if available
id_from_roles = set()
prot_from_roles = set()
if "feature_roles_df" in globals():
    if "role" in feature_roles_df.columns:
        id_from_roles = set(
            feature_roles_df.loc[feature_roles_df["role"] == "id", "column"]
        ) & set(df.columns)
    if "is_protected" in feature_roles_df.columns:
        prot_from_roles = set(
            feature_roles_df.loc[feature_roles_df["is_protected"].astype(bool), "column"]
        ) & set(df.columns)

# From column_type_map hints (is_id / is_protected)
id_from_map = set()
prot_from_map = set()
for col_name, meta in column_type_map.items():
    if col_name not in df.columns:
        continue
    if bool(meta.get("is_id", False)):
        id_from_map.add(col_name)
    if bool(meta.get("is_protected", False)):
        prot_from_map.add(col_name)

# Final sets
id_columns_final = (id_from_cfg | id_from_roles | id_from_map) & set(df.columns)
protected_columns_final = (prot_from_cfg | prot_from_roles | prot_from_map) & set(df.columns)
exclude_from_model = id_columns_final | protected_columns_final

# Build registry rows
registry_rows_226 = []
for col in sorted(exclude_from_model):
    sources = []
    if col in id_from_cfg:
        sources.append("config:id")
    if col in prot_from_cfg:
        sources.append("config:protected")
    if col in id_from_roles:
        sources.append("roles:id")
    if col in prot_from_roles:
        sources.append("roles:protected")
    if col in id_from_map:
        sources.append("map:is_id")
    if col in prot_from_map:
        sources.append("map:is_protected")

    registry_rows_226.append(
        {
            "column":             col,
            "dtype":              str(df[col].dtype),
            "is_id":              col in id_columns_final,
            "is_protected":       col in protected_columns_final,
            "include_in_model":   not (col in exclude_from_model),
            "source_tags":        ",".join(sources),
        }
    )

registry_df_226 = pd.DataFrame(registry_rows_226)

id_prot_path = SEC2_REPORTS_DIR / "id_protected_registry.csv"
tmp_226_csv = id_prot_path.with_suffix(".tmp.csv")
registry_df_226.to_csv(tmp_226_csv, index=False)
os.replace(tmp_226_csv, id_prot_path)
print(f"üíæ Wrote ID/protected registry ‚Üí {id_prot_path}")


# registry (head)
print("\nüìä 2.2.6 ID/protected registry (head):")
if not registry_df_226.empty:
    display(
        registry_df_226[
            ["column", "dtype", "is_id", "is_protected", "include_in_model", "source_tags"]
        ].head(20)
    )
else:
    print("   (no ID/protected columns registered)")

# Persist governance JSON under ARTIFACTS_DIR
protected_json_path = ARTIFACTS_DIR / "protected_columns.json"
protected_payload = {
    "id_columns":          sorted(id_columns_final),
    "protected_columns":   sorted(protected_columns_final),
    "exclude_from_model":  sorted(exclude_from_model),
    "timestamp":           datetime.utcnow().isoformat(timespec="seconds") + "Z",
}
with open(protected_json_path, "w", encoding="utf-8") as f:
    json.dump(protected_payload, f, indent=2)
print(f"üíæ Wrote governance contract ‚Üí {protected_json_path}")

# Update column_type_map flags
for col_name, meta in column_type_map.items():
    if col_name not in df.columns:
        continue
    meta["is_id"] = col_name in id_columns_final
    meta["is_protected"] = col_name in protected_columns_final
    # default include_in_model flag
    hints = meta.get("hints", {}) or {}
    hints["include_in_model"] = not (col_name in exclude_from_model)
    meta["hints"] = hints
    column_type_map[col_name] = meta

with open(type_map_path, "w", encoding="utf-8") as f:
    json.dump(column_type_map, f, indent=2)
print(f"üíæ Updated column type map with ID/protected flags ‚Üí {type_map_path}")

# Append diagnostics row (2.2.6)
summary_226 = {
    "section":               "2.2.6",
    "section_name":          "ID & protected columns registration",
    "check":                 "Persist ID/protected contracts for downstream steps",
    "level":                 "info",
    "status":                "OK",
    "n_id_columns":          int(len(id_columns_final)),
    "n_protected_columns":   int(len(protected_columns_final)),
    "n_excluded_from_model": int(len(exclude_from_model)),
    "detail":                f"protected_columns.json; id_protected_registry.csv; type map updated at {type_map_path.name}",
    "timestamp":             pd.Timestamp.utcnow(),
}

if "_append_sec2" in globals():
    _append_sec2(pd.DataFrame([summary_226]))
else:
    path = SECTION2_REPORT_PATH
    tmp = path.with_suffix(path.suffix + ".tmp")
    chunk = pd.DataFrame([summary_226])
    try:
        path.parent.mkdir(parents=True, exist_ok=True)
        if path.exists():
            ex = pd.read_csv(path)
            allc = pd.Index(ex.columns).union(chunk.columns)
            out = pd.concat(
                [ex.reindex(columns=allc), chunk.reindex(columns=allc)],
                ignore_index=True,
            )
        else:
            out = chunk
        out.to_csv(tmp, index=False)
        os.replace(tmp, path)
        print(f"üßæ Appended 2.2.6 summary ‚Üí {path}")
    except Exception as e:
        if tmp.exists():
            try:
                tmp.unlink()
            except Exception:
                pass
        print(f"‚ö†Ô∏è Could not append 2.2.6 summary: {e}")

print("‚úÖ 2.2.6 complete.")

# OUTPUT:
2.2.6 üõ°Ô∏è ID & protected columns registration
üíæ Wrote ID/protected registry ‚Üí /Users/b/DATA/PROJECTS/Telco/Level_3/resources/reports/section2/id_protected_registry.csv

üìä 2.2.6 ID/protected registry (head):
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>column</th>
      <th>dtype</th>
      <th>is_id</th>
      <th>is_protected</th>
      <th>include_in_model</th>
      <th>source_tags</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Churn</td>
      <td>category</td>
      <td>False</td>
      <td>True</td>
      <td>False</td>
      <td>roles:protected,map:is_protected</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Churn_flag</td>
      <td>Int8</td>
      <td>False</td>
      <td>True</td>
      <td>False</td>
      <td>roles:protected,map:is_protected</td>
    </tr>
    <tr>
      <th>2</th>
      <td>customerID</td>
      <td>object</td>
      <td>True</td>
      <td>True</td>
      <td>False</td>
      <td>roles:id,roles:protected,map:is_id,map:is_prot...</td>
    </tr>
  </tbody>
</table>
</div>
üíæ Wrote governance contract ‚Üí /Users/b/DATA/PROJECTS/Telco/Level_3/resources/artifacts/protected_columns.json
üíæ Updated column type map with ID/protected flags ‚Üí /Users/b/DATA/PROJECTS/Telco/Level_3/resources/reports/section2/type_detection/column_type_map.json
üßæ Appended 2.2.6 summary ‚Üí /Users/b/DATA/PROJECTS/Telco/Level_3/resources/reports/section2/section2_data_quality_20251209_181006.csv
‚úÖ 2.2.6 complete.
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_54139/2976865035.py:107: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
  "timestamp":           datetime.utcnow().isoformat(timespec="seconds") + "Z",
```

># SOLUTION:
