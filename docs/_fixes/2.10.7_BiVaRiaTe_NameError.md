># Q:

```py

---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
Cell In[2], line 16
      9     _ip_image = None
     11 # -------------------------------------------------------------------
     12 # 0) Config
     13 # -------------------------------------------------------------------
     14 default_bivar_vis_cfg = {
     15     "ENABLED": True,
---> 16     "OUTPUT_DIR": str(bivariate_figures_root_210),
     17     "N_TOP_PAIRS": 30,
     18     "NETWORK_MIN_STRENGTH": 0.3,  # threshold for edges in feature network
     19 }
     20 bivar_vis_cfg = _get_cfg_210("BIVARIATE_VISUALS", default_bivar_vis_cfg)
     22 bivar_vis_enabled_2107 = bool(bivar_vis_cfg.get("ENABLED", True))

NameError: name 'bivariate_figures_root_210' is not defined
```



```py
# 2.10.7 | Visual Bivariate Exploration (enhanced)
print("2.10.7 Visual bivariate exploration (scatter, hexbin, box, violin, heatmaps, network)")

# Optional: for preview gallery in notebooks
try:
    from IPython.display import display as _ip_display, Image as _ip_image
except Exception:
    _ip_display = None
    _ip_image = None

# -------------------------------------------------------------------
# 0) Config
# -------------------------------------------------------------------
default_bivar_vis_cfg = {
    "ENABLED": True,
    "OUTPUT_DIR": str(bivariate_figures_root_210),
    "N_TOP_PAIRS": 30,
    "NETWORK_MIN_STRENGTH": 0.3,  # threshold for edges in feature network
}
bivar_vis_cfg = _get_cfg_210("BIVARIATE_VISUALS", default_bivar_vis_cfg)

bivar_vis_enabled_2107 = bool(bivar_vis_cfg.get("ENABLED", True))
bivar_vis_output_dir_2107 = Path(
    bivar_vis_cfg.get("OUTPUT_DIR", str(bivariate_figures_root_210))
).resolve()
bivar_vis_top_pairs_2107 = int(bivar_vis_cfg.get("N_TOP_PAIRS", 30))
network_min_strength_2107 = float(bivar_vis_cfg.get("NETWORK_MIN_STRENGTH", 0.3))

# Ensure directory structure exists
nn_dir_2107 = (bivar_vis_output_dir_2107 / "numeric_numeric").resolve()
cn_dir_2107 = (bivar_vis_output_dir_2107 / "categorical_numeric").resolve()
cc_dir_2107 = (bivar_vis_output_dir_2107 / "categorical_categorical").resolve()
net_dir_2107 = (bivar_vis_output_dir_2107 / "feature_network").resolve()

for _d in [nn_dir_2107, cn_dir_2107, cc_dir_2107, net_dir_2107]:
    _d.mkdir(parents=True, exist_ok=True)

bivar_visual_index_rows_2107 = []
n_plots_2107 = 0

# We'll also accumulate edges for the feature network
network_edges_2107 = []  # (feature_1, feature_2, strength)

# Safety
if "df_clean" not in globals():
    raise RuntimeError("‚ùå df_clean not found; 2.10.7 requires cleaned dataset")

# -------------------------------------------------------------------
# 1) Numeric‚Äìnumeric visuals: scatter + hexbin
# -------------------------------------------------------------------
if bivar_vis_enabled_2107:
    if (
        "bivar_num_df_2104" in globals()
        and isinstance(bivar_num_df_2104, pd.DataFrame)
        and not bivar_num_df_2104.empty
    ):
        num_pairs_sorted = bivar_num_df_2104.copy()

        # strength = max(|pearson|, |spearman|)
        for col in ["pearson_r", "spearman_rho"]:
            if col not in num_pairs_sorted.columns:
                num_pairs_sorted[col] = np.nan

        num_pairs_sorted["strength"] = num_pairs_sorted[
            ["pearson_r", "spearman_rho"]
        ].abs().max(axis=1)

        num_pairs_sorted = num_pairs_sorted.sort_values(
            "strength", ascending=False
        ).head(bivar_vis_top_pairs_2107)

        for _, row_ in num_pairs_sorted.iterrows():
            f1 = row_["feature_1"]
            f2 = row_["feature_2"]

            if f1 not in df_clean.columns or f2 not in df_clean.columns:
                continue

            s1 = df_clean[f1]
            s2 = df_clean[f2]
            valid = s1.notna() & s2.notna()
            if valid.sum() < 5:
                continue

            s1 = s1[valid].astype(float)
            s2 = s2[valid].astype(float)

            # 1A) Scatter
            fig, ax = plt.subplots(figsize=(5, 4))
            ax.scatter(s1, s2, alpha=0.4, s=8)
            ax.set_xlabel(f1)
            ax.set_ylabel(f2)
            ax.set_title(f"{f1} vs {f2} (scatter)")

            scatter_path = (nn_dir_2107 / f"{f1}__vs__{f2}_scatter.png").resolve()
            fig.tight_layout()
            fig.savefig(scatter_path)
            plt.close(fig)

            bivar_visual_index_rows_2107.append(
                {
                    "feature_1": f1,
                    "feature_2": f2,
                    "kind": "numeric_numeric_scatter",
                    "score": float(row_.get("strength", np.nan)),
                    "path": str(scatter_path),
                }
            )
            n_plots_2107 += 1

            # 1B) Hexbin (great for dense relationships)
            fig, ax = plt.subplots(figsize=(5, 4))
            hb = ax.hexbin(s1, s2, gridsize=30)
            ax.set_xlabel(f1)
            ax.set_ylabel(f2)
            ax.set_title(f"{f1} vs {f2} (hexbin density)")
            cbar = fig.colorbar(hb, ax=ax)
            cbar.set_label("count")

            hex_path = (nn_dir_2107 / f"{f1}__vs__{f2}_hexbin.png").resolve()
            fig.tight_layout()
            fig.savefig(hex_path)
            plt.close(fig)

            bivar_visual_index_rows_2107.append(
                {
                    "feature_1": f1,
                    "feature_2": f2,
                    "kind": "numeric_numeric_hexbin",
                    "score": float(row_.get("strength", np.nan)),
                    "path": str(hex_path),
                }
            )
            n_plots_2107 += 1

            # Add edge for network
            strength_val = float(row_.get("strength", np.nan))
            if not np.isnan(strength_val):
                network_edges_2107.append((f1, f2, strength_val))

# -------------------------------------------------------------------
# 2) Categorical‚Äìnumeric visuals: boxplot + violin-ish density
# -------------------------------------------------------------------
if (
    bivar_vis_enabled_2107
    and "bivar_cross_df_2106" in globals()
    and isinstance(bivar_cross_df_2106, pd.DataFrame)
    and not bivar_cross_df_2106.empty
):
    cross_sorted = bivar_cross_df_2106.copy()

    # Score based on -log10(p) if available
    eps = 1e-12
    if "p_value" in cross_sorted.columns:
        cross_sorted["score"] = -np.log10(cross_sorted["p_value"] + eps)
    else:
        cross_sorted["score"] = 0.0

    cross_sorted = cross_sorted.sort_values(
        "score", ascending=False
    ).head(bivar_vis_top_pairs_2107)

    for _, row_ in cross_sorted.iterrows():
        cat_col = row_["categorical_feature"]
        num_col = row_["numeric_feature"]

        if cat_col not in df_clean.columns or num_col not in df_clean.columns:
            continue

        s_cat = df_clean[cat_col]
        s_num = df_clean[num_col]
        valid = s_cat.notna() & s_num.notna()
        if valid.sum() < 5:
            continue

        s_cat = s_cat[valid].astype("object")
        s_num = s_num[valid].astype(float)

        if s_cat.nunique() < 2:
            continue

        # To stabilize visuals, sort levels by frequency
        levels = list(s_cat.value_counts().index)

        # 2A) Boxplot
        fig, ax = plt.subplots(figsize=(6, 4))
        data = [s_num[s_cat == level].values for level in levels]
        ax.boxplot(
            data,
            tick_labels=levels,  # updated param name (no DeprecationWarning)
            showfliers=False,
        )
        ax.set_xlabel(cat_col)
        ax.set_ylabel(num_col)
        ax.set_title(f"{num_col} by {cat_col} (boxplot)")
        plt.setp(ax.get_xticklabels(), rotation=45, ha="right")

        box_path = (cn_dir_2107 / f"{cat_col}__vs__{num_col}_box.png").resolve()
        fig.tight_layout()
        fig.savefig(box_path)
        plt.close(fig)

        bivar_visual_index_rows_2107.append(
            {
                "feature_1": cat_col,
                "feature_2": num_col,
                "kind": "categorical_numeric_box",
                "score": float(row_.get("score", np.nan)),
                "path": str(box_path),
            }
        )
        n_plots_2107 += 1

        # 2B) Violin-ish density: multiple KDE curves mirrored per category
        #     (simple approximation, avoids extra dependencies)
        fig, ax = plt.subplots(figsize=(6, 4))

        # Normalize position to 0..1 horizontally based on category index
        for idx, level in enumerate(levels):
            vals = s_num[s_cat == level].dropna().values
            if vals.size < 5:
                continue

            # Build a simple smoothed histogram as a pseudo-KDE
            try:
                counts, bin_edges = np.histogram(vals, bins=20, density=True)
                bin_centers = 0.5 * (bin_edges[:-1] + bin_edges[1:])
                # Scale to a max width (violin half-width)
                if counts.max() > 0:
                    width = 0.4 * (counts / counts.max())
                else:
                    width = np.zeros_like(counts)

                x_center = idx + 1  # boxplot categories are 1..N on x-axis

                # Draw left and right "violin" using fill_betweenx
                ax.fill_betweenx(
                    bin_centers,
                    x_center - width,
                    x_center + width,
                    alpha=0.3,
                )
            except Exception:
                # If anything goes wrong, skip violin for this category
                continue

        ax.set_xticks(range(1, len(levels) + 1))
        ax.set_xticklabels(levels, rotation=45, ha="right")
        ax.set_xlabel(cat_col)
        ax.set_ylabel(num_col)
        ax.set_title(f"{num_col} by {cat_col} (violin-style density)")

        violin_path = (cn_dir_2107 / f"{cat_col}__vs__{num_col}_violin.png").resolve()
        fig.tight_layout()
        fig.savefig(violin_path)
        plt.close(fig)

        bivar_visual_index_rows_2107.append(
            {
                "feature_1": cat_col,
                "feature_2": num_col,
                "kind": "categorical_numeric_violin",
                "score": float(row_.get("score", np.nan)),
                "path": str(violin_path),
            }
        )
        n_plots_2107 += 1

# -------------------------------------------------------------------
# 3) Categorical‚Äìcategorical visuals: contingency heatmaps
# -------------------------------------------------------------------
if (
    bivar_vis_enabled_2107
    and "bivar_cat_df_2105" in globals()
    and isinstance(bivar_cat_df_2105, pd.DataFrame)
    and not bivar_cat_df_2105.empty
):
    cat_pairs_sorted = bivar_cat_df_2105.copy()

    # Try to use a strength-like column if present, else default
    strength_col = None
    for candidate_col in ["cramers_v", "theils_u", "association_strength", "score"]:
        if candidate_col in cat_pairs_sorted.columns:
            strength_col = candidate_col
            break

    if strength_col is None:
        cat_pairs_sorted["strength"] = 0.0
        strength_col = "strength"

    cat_pairs_sorted = cat_pairs_sorted.sort_values(
        strength_col, ascending=False
    ).head(bivar_vis_top_pairs_2107)

    for _, row_ in cat_pairs_sorted.iterrows():
        cat1 = row_["feature_1"]
        cat2 = row_["feature_2"]

        if cat1 not in df_clean.columns or cat2 not in df_clean.columns:
            continue

        s1 = df_clean[cat1].astype("object")
        s2 = df_clean[cat2].astype("object")

        valid = s1.notna() & s2.notna()
        if valid.sum() < 5:
            continue

        s1 = s1[valid]
        s2 = s2[valid]

        if s1.nunique() < 2 or s2.nunique() < 2:
            continue

        # Build contingency table
        ct = pd.crosstab(s1, s2, dropna=False)

        fig, ax = plt.subplots(figsize=(6, 5))
        im = ax.imshow(ct.values, aspect="auto")
        ax.set_title(f"{cat1} √ó {cat2} (contingency heatmap)")
        ax.set_xlabel(cat2)
        ax.set_ylabel(cat1)

        ax.set_xticks(range(len(ct.columns)))
        ax.set_xticklabels(ct.columns, rotation=45, ha="right")
        ax.set_yticks(range(len(ct.index)))
        ax.set_yticklabels(ct.index)

        cbar = fig.colorbar(im, ax=ax)
        cbar.set_label("count")

        heat_path = (cc_dir_2107 / f"{cat1}__x__{cat2}_heatmap.png").resolve()
        fig.tight_layout()
        fig.savefig(heat_path)
        plt.close(fig)

        strength_val = float(row_.get(strength_col, np.nan))

        bivar_visual_index_rows_2107.append(
            {
                "feature_1": cat1,
                "feature_2": cat2,
                "kind": "categorical_categorical_heatmap",
                "score": strength_val,
                "path": str(heat_path),
            }
        )
        n_plots_2107 += 1

        if not np.isnan(strength_val):
            network_edges_2107.append((cat1, cat2, abs(strength_val)))

# -------------------------------------------------------------------
# 4) Feature interaction network graph
# -------------------------------------------------------------------
network_path_2107 = None

if bivar_vis_enabled_2107 and network_edges_2107:
    # Filter edges above a minimum strength
    strengths = np.array([e[2] for e in network_edges_2107], dtype=float)
    strengths = strengths[~np.isnan(strengths)]
    if strengths.size > 0:
        max_strength = strengths.max()
    else:
        max_strength = 1.0

    if max_strength <= 0:
        max_strength = 1.0

    # Keep edges above configured threshold fraction of max
    threshold_abs = network_min_strength_2107 * max_strength
    filtered_edges = [
        e for e in network_edges_2107
        if not np.isnan(e[2]) and e[2] >= threshold_abs
    ]

    if filtered_edges:
        # Nodes are all unique features from edges
        nodes = sorted(set([e[0] for e in filtered_edges] + [e[1] for e in filtered_edges]))
        n_nodes = len(nodes)

        # Simple circular layout
        angles = np.linspace(0, 2 * np.pi, n_nodes, endpoint=False)
        coords = {node: (np.cos(a), np.sin(a)) for node, a in zip(nodes, angles)}

        fig, ax = plt.subplots(figsize=(8, 8))
        ax.set_aspect("equal")
        ax.axis("off")
        ax.set_title("Bivariate relationship network (strongest edges)")

        # Draw edges
        for u, v, strength in filtered_edges:
            x1, y1 = coords[u]
            x2, y2 = coords[v]
            # Map strength to line width and alpha
            lw = 0.5 + 4.0 * (strength / max_strength)
            alpha = 0.2 + 0.6 * (strength / max_strength)
            ax.plot(
                [x1, x2],
                [y1, y2],
                linewidth=lw,
                alpha=alpha,
            )

        # Draw nodes
        for node, (x, y) in coords.items():
            ax.scatter([x], [y], s=40, zorder=3)
            ax.text(
                x,
                y,
                node,
                fontsize=8,
                ha="center",
                va="center",
                bbox=dict(boxstyle="round,pad=0.2", fc="white", ec="none", alpha=0.7),
            )

        network_path_2107 = (net_dir_2107 / "bivariate_feature_network.png").resolve()
        fig.tight_layout()
        fig.savefig(network_path_2107, dpi=200)
        plt.close(fig)

        bivar_visual_index_rows_2107.append(
            {
                "feature_1": None,
                "feature_2": None,
                "kind": "feature_network",
                "score": float(max_strength),
                "path": str(network_path_2107),
            }
        )
        n_plots_2107 += 1

# -------------------------------------------------------------------
# 5) Visual index CSV for Part B
# -------------------------------------------------------------------
bivar_vis_index_path_2107 = section2_reports_dir_210 / "bivariate_visual_index.csv"
if bivar_visual_index_rows_2107:
    vis_idx_df_2107 = pd.DataFrame(bivar_visual_index_rows_2107)
    tmp_path_2107 = bivar_vis_index_path_2107.with_suffix(".tmp.csv")
    vis_idx_df_2107.to_csv(tmp_path_2107, index=False)
    os.replace(tmp_path_2107, bivar_vis_index_path_2107)
else:
    vis_idx_df_2107 = pd.DataFrame(
        columns=["feature_1", "feature_2", "kind", "score", "path"]
    )

if (n_plots_2107 > 0) or (not bivar_vis_enabled_2107):
    status_2107 = "OK"
else:
    status_2107 = "WARN"

summary_2107 = pd.DataFrame([{
    "section": "2.10.7",
    "section_name": "Visual bivariate exploration",
    "check": "Generate scatter, hexbin, box, violin, cat‚Äìcat heatmaps, and network graph for high-interest feature pairs",
    "level": "info",
    "status": status_2107,
    "n_plots": int(n_plots_2107),
    "detail": getattr(bivar_vis_output_dir_2107, "name", str(bivar_vis_output_dir_2107)),
    "timestamp": pd.Timestamp.utcnow(),
}])

append_sec2(summary_2107, SECTION2_REPORT_PATH)
print(f"   ‚úÖ 2.10.7 wrote {n_plots_2107} plot(s); index ‚Üí {bivar_vis_index_path_2107}")

# -------------------------------------------------------------------
# 6) Preview gallery (top visuals)
# -------------------------------------------------------------------
if _ip_display is not None and not vis_idx_df_2107.empty:
    print("   üñº 2.10.7 preview gallery (top 6 by score):")
    # Sort by score (descending), but keep feature_network near the end
    vis_idx_sorted = vis_idx_df_2107.sort_values(
        by=["score"],
        ascending=False,
        na_position="last",
    ).head(6)

    for _, r in vis_idx_sorted.iterrows():
        kind = r["kind"]
        f1 = r.get("feature_1", None)
        f2 = r.get("feature_2", None)
        print(f"   ‚Ä¢ {kind} ‚Äî {f1} vs {f2}" if f1 or f2 else f"   ‚Ä¢ {kind}")
        path = r.get("path", None)
        if path and os.path.exists(path):
            try:
                _ip_display(_ip_image(filename=path))
            except Exception as e:
                print(f"     (could not display image: {e})")
else:
    print("   ‚ÑπÔ∏è Preview gallery skipped (no IPython display or empty index).")

display(summary_2107)
```