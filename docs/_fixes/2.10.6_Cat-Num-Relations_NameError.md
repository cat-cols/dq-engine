
```python
# 2.10.6 | Categorical–Numeric Relationships
print("2.10.6 Categorical–numeric relationships")

default_bivar_cross_cfg = {
    "ENABLED": True,
    "TESTS": ["anova", "kruskal"],
    "MUTUAL_INFORMATION": True,
    "TARGETS": [],  # optional: for MI focus on specific targets (kept generic here)
    "OUTPUT_FILE": "bivariate_cross_association.csv",
}
bivar_cross_cfg = _get_cfg_210("BIVARIATE_CROSS", default_bivar_cross_cfg)

bivar_cross_enabled_2106 = bool(bivar_cross_cfg.get("ENABLED", True))
bivar_cross_tests_2106 = list(bivar_cross_cfg.get("TESTS", ["anova", "kruskal"]))
bivar_cross_use_mi_2106 = bool(bivar_cross_cfg.get("MUTUAL_INFORMATION", True))
bivar_cross_targets_2106 = list(bivar_cross_cfg.get("TARGETS", []))
bivar_cross_output_file_2106 = str(
    bivar_cross_cfg.get("OUTPUT_FILE", "bivariate_cross_association.csv")
)

bivar_cross_matrix_path_2106 = section2_reports_dir_210 / bivar_cross_output_file_2106

bivar_cross_df_2106 = pd.DataFrame()
n_pairs_2106 = 0
n_significant_2106 = 0

# Try to import SciPy for real p-values; fall back to approximate F-like statistic otherwise
try:
    from scipy.stats import f_oneway as _f_oneway_2106, kruskal as _kruskal_2106
    _HAS_SCIPY_2106 = True
except Exception:
    _HAS_SCIPY_2106 = False

def _qcut_codes_2106(s: pd.Series, q: int = 5) -> pd.Series:
    try:
        bins = pd.qcut(s, q=q, duplicates="drop")
        return bins.astype("str")
    except Exception:
        return pd.Series(index=s.index, data=np.nan)

def _entropy_generic_2106(s: pd.Series) -> float:
    vc = result.index = result.index.infer_objects()
    p = vc.values.astype(float)
    with np.errstate(divide="ignore", invalid="ignore"):
        return float(-(p * np.log2(p + 1e-15)).sum()) if p.size > 0 else np.nan

def _joint_entropy_2106(x: pd.Series, y: pd.Series) -> float:
    df_xy = pd.DataFrame({"x": x, "y": y}).dropna()
    if df_xy.empty:
        return np.nan
    vc = df_xy.value_counts(normalize=True)
    p = vc.values.astype(float)
    with np.errstate(divide="ignore", invalid="ignore"):
        return float(-(p * np.log2(p + 1e-15)).sum()) if p.size > 0 else np.nan

def _mutual_information_2106(x: pd.Series, y: pd.Series) -> float:
    df_xy = pd.DataFrame({"x": x, "y": y}).dropna()
    if df_xy.empty:
        return np.nan
    h_x = _entropy_generic_2106(df_xy["x"])
    h_y = _entropy_generic_2106(df_xy["y"])
    h_xy = _joint_entropy_2106(df_xy["x"], df_xy["y"])
    if any(np.isnan(v) for v in [h_x, h_y, h_xy]):
        return np.nan
    mi = h_x + h_y - h_xy
    return float(max(0.0, mi))

if bivar_cross_enabled_2106:
    # Numeric features (reuse 2.10.1 if available)
    if (
        "num_summary_df_2101" in globals()
        and isinstance(num_summary_df_2101, pd.DataFrame)
        and not num_summary_df_2101.empty
    ):
        numeric_cols_2106 = [
            c for c in num_summary_df_2101["feature"] if c in df_clean.columns
        ]
    else:
        from pandas.api.types import is_numeric_dtype, is_bool_dtype

        numeric_cols_2106 = [
            c
            for c in df_clean.columns
            if is_numeric_dtype(df_clean[c]) and not is_bool_dtype(df_clean[c])
        ]

    # Categorical features (reuse 2.10.2 if available)
    if (
        "cat_summary_df_2102" in globals()
        and isinstance(cat_summary_df_2102, pd.DataFrame)
        and not cat_summary_df_2102.empty
    ):
        categorical_cols_2106 = [
            c for c in cat_summary_df_2102["feature"] if c in df_clean.columns
        ]
    else:
        from pandas.api.types import is_numeric_dtype, is_bool_dtype

        categorical_cols_2106 = [
            c
            for c in df_clean.columns
            if (not is_numeric_dtype(df_clean[c])) or is_bool_dtype(df_clean[c])
        ]

    rows_2106 = []
    for cat_col in categorical_cols_2106:
        for num_col in numeric_cols_2106:
            s_cat = df_clean[cat_col]
            s_num = df_clean[num_col]
            valid = s_cat.notna() & s_num.notna()
            if valid.sum() < 3:
                continue

            s_cat_valid = s_cat[valid].astype("object")
            s_num_valid = s_num[valid].astype(float)

            # group arrays for tests
            groups = [
                s_num_valid[s_cat_valid == level].values
                for level in s_cat_valid.unique()
            ]
            groups = [g for g in groups if g.size > 0]

            test_method_used = None
            test_stat = np.nan
            p_value = np.nan

            if "anova" in bivar_cross_tests_2106 and len(groups) >= 2:
                test_method_used = "anova"
                if _HAS_SCIPY_2106:
                    try:
                        stat, p = _f_oneway_2106(*groups)
                        test_stat = float(stat)
                        p_value = float(p)
                    except Exception:
                        test_stat = np.nan
                        p_value = np.nan
                else:
                    # simple F-like ratio as placeholder when SciPy missing
                    grand_mean = s_num_valid.mean()
                    ss_between = sum(
                        g.size * (g.mean() - grand_mean) ** 2 for g in groups
                    )
                    ss_within = sum(((g - g.mean()) ** 2).sum() for g in groups)
                    df_between = len(groups) - 1
                    df_within = max(1, valid.sum() - len(groups))
                    ms_between = ss_between / df_between if df_between > 0 else np.nan
                    ms_within = ss_within / df_within if df_within > 0 else np.nan
                    test_stat = (
                        (ms_between / ms_within)
                        if (ms_between > 0 and ms_within > 0)
                        else np.nan
                    )
                    p_value = np.nan  # cannot compute exact p without SciPy

            elif "kruskal" in bivar_cross_tests_2106 and len(groups) >= 2:
                test_method_used = "kruskal"
                if _HAS_SCIPY_2106:
                    try:
                        stat, p = _kruskal_2106(*groups)
                        test_stat = float(stat)
                        p_value = float(p)
                    except Exception:
                        test_stat = np.nan
                        p_value = np.nan
                else:
                    test_stat = np.nan
                    p_value = np.nan

            # Mutual information: between categorical and binned numeric
            mi_val = np.nan
            if bivar_cross_use_mi_2106:
                binned_num = _qcut_codes_2106(s_num_valid, q=5)
                mi_val = _mutual_information_2106(s_cat_valid, binned_num)

            # Effect label
            if not np.isnan(p_value):
                if p_value < 0.01:
                    effect_label = "Strong"
                elif p_value < 0.05:
                    effect_label = "Moderate"
                elif p_value < 0.1:
                    effect_label = "Weak"
                else:
                    effect_label = "Not significant"
            else:
                if not np.isnan(mi_val) and mi_val >= 0.5:
                    effect_label = "Strong (MI)"
                elif not np.isnan(mi_val) and mi_val >= 0.2:
                    effect_label = "Moderate (MI)"
                elif not np.isnan(mi_val) and mi_val > 0:
                    effect_label = "Weak (MI)"
                else:
                    effect_label = "Unknown"

            rows_2106.append(
                {
                    "categorical_feature": cat_col,
                    "numeric_feature": num_col,
                    "test_method": test_method_used,
                    "test_statistic": test_stat,
                    "p_value": p_value,
                    "mutual_information": mi_val,
                    "effect_label": effect_label,
                }
            )

    bivar_cross_df_2106 = pd.DataFrame(rows_2106)
    n_pairs_2106 = int(bivar_cross_df_2106.shape[0])
    n_significant_2106 = int(
        (
            bivar_cross_df_2106["p_value"].notna()
            & (bivar_cross_df_2106["p_value"] < 0.05)
        ).sum()
    )

    tmp_path_2106 = bivar_cross_matrix_path_2106.with_suffix(".tmp.csv")
    bivar_cross_df_2106.to_csv(tmp_path_2106, index=False)
    os.replace(tmp_path_2106, bivar_cross_matrix_path_2106)

if n_pairs_2106 == 0:
    status_2106 = "WARN"
else:
    frac_sig_2106 = n_significant_2106 / max(1, n_pairs_2106)
    if frac_sig_2106 <= 0.3:
        status_2106 = "OK"
    elif frac_sig_2106 <= 0.7:
        status_2106 = "WARN"
    else:
        status_2106 = "FAIL"

sig_rate_2106 = (
    float(n_significant_2106) / n_pairs_2106
    if n_pairs_2106 and n_pairs_2106 > 0
    else None
)

summary_2106 = pd.DataFrame([{
    "section": "2.10.6",
    "section_name": "Categorical–numeric relationships",
    "check": "Run group difference tests and mutual information for cat–num pairs",
    "level": "info",
    "status": status_2106,
    "n_pairs": int(n_pairs_2106),
    "n_significant": int(n_significant_2106),
    "significance_rate": sig_rate_2106,
    "detail": str(bivar_cross_matrix_path_2106),
    "timestamp": pd.Timestamp.utcnow(),
}])

append_sec2(summary_2106, SECTION2_REPORT_PATH)

display(summary_2106)

---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
Cell In[230], line 174
    172 if bivar_cross_use_mi_2106:
    173     binned_num = _qcut_codes_2106(s_num_valid, q=5)
--> 174     mi_val = _mutual_information_2106(s_cat_valid, binned_num)
    176 # Effect label
    177 if not np.isnan(p_value):

Cell In[230], line 60, in _mutual_information_2106(x, y)
     58 if df_xy.empty:
     59     return np.nan
---> 60 h_x = _entropy_generic_2106(df_xy["x"])
     61 h_y = _entropy_generic_2106(df_xy["y"])
     62 h_xy = _joint_entropy_2106(df_xy["x"], df_xy["y"])

Cell In[230], line 42, in _entropy_generic_2106(s)
     41 def _entropy_generic_2106(s: pd.Series) -> float:
---> 42     vc = result.index = result.index.infer_objects()
     43     p = vc.values.astype(float)
     44     with np.errstate(divide="ignore", invalid="ignore"):

NameError: name 'result' is not defined
```

