># Why did the VIF fail?

```py
# 2.7.13 | Multicollinearity Check (VIF)
print("2.7.13 | Multicollinearity Check (VIF)")

multi_cfg = CONFIG.get("MULTICOLLINEARITY", {})
multi_enabled_2713 = bool(multi_cfg.get("ENABLED", True))
multi_target_2713 = multi_cfg.get("TARGET_COLUMNS", "numeric")
multi_max_vif_2713 = float(multi_cfg.get("MAX_VIF_THRESHOLD", 10.0))
multi_output_file_2713 = multi_cfg.get("OUTPUT_FILE", "vif_report.csv")
multi_exclude_cols_2713 = multi_cfg.get("EXCLUDE_COLUMNS", [])

vif_rows_2713 = []
n_cols_eval_2713 = 0
n_high_vif_2713 = 0
vif_detail_2713 = None
vif_status_2713 = "SKIPPED"

if not multi_enabled_2713:
    print("   ‚ö†Ô∏è 2.7.13 disabled")
else:
    # 1) Select feature set
    if isinstance(multi_target_2713, str) and multi_target_2713 == "numeric":
        candidate_cols = [c for c in df_27.columns if is_numeric_series(df_27[c])]
    else:
        candidate_cols = []

    if multi_exclude_cols_2713:
        candidate_cols = [c for c in candidate_cols if c not in multi_exclude_cols_2713]

    print(f"   üìä Numeric cols for VIF: {len(candidate_cols)} - {candidate_cols}")

    if len(candidate_cols) < 2:
        print(f"   ‚ö†Ô∏è 2.7.13: {len(candidate_cols)} numeric cols; needs data prep")
        vif_status_2713 = "WARN"  # ‚úÖ CORRECT
        n_cols_eval_2713 = len(candidate_cols)
    else:
        X = df_27[candidate_cols].copy().dropna()
        min_rows = multi_cfg.get("MIN_ROWS", 30)

        if X.shape[0] < min_rows:
            print(f"   ‚ö†Ô∏è Too few rows ({X.shape[0]}); FAIL")
            vif_status_2713 = "FAIL"
        else:
            # ‚úÖ BULLETPROOF VIF COMPUTATION
            X_numeric = X.select_dtypes(include=[np.number]).copy()
            X_numeric = X_numeric.fillna(X_numeric.mean(numeric_only=True))

            if X_numeric.shape[1] >= 2:
                X_with_const = sm.add_constant(X_numeric, has_constant="add")

                vif_vals = []
                try:
                    for i, col in enumerate(X_with_const.columns[1:], 1):
                        vif_val = variance_inflation_factor(X_with_const.values, i)
                        if np.isfinite(vif_val):
                            vif_vals.append((col, float(vif_val)))
                            print(f"   ‚úÖ {col}: VIF={vif_val:.2f}")
                        else:
                            print(f"   ‚ö†Ô∏è {col}: VIF infinite/NaN")
                except Exception as e:
                    print(f"   ‚ùå VIF failed: {e}")
                    vif_status_2713 = "FAIL"

                # ‚úÖ PROCESS RESULTS (only if we have VIFs)
                if vif_vals:
                    for col, vif_val in vif_vals:
                        if vif_val < 5:
                            cat = "low"
                        elif vif_val < multi_max_vif_2713:
                            cat = "moderate"
                        else:
                            cat = "high"
                        notes = f"VIF>={multi_max_vif_2713:.1f}; drop/regularize" if cat == "high" else ""
                        vif_rows_2713.append({
                            "column": col, "vif_value": vif_val,
                            "vif_category": cat, "notes": notes
                        })

                    df_vif_2713 = pd.DataFrame(vif_rows_2713)
                    vif_path_2713 = sec27_reports_dir / multi_output_file_2713
                    df_vif_2713.to_csv(vif_path_2713, index=False)
                    print(f"   ‚úÖ VIF report: {vif_path_2713}")

                    n_cols_eval_2713 = len(vif_rows_2713)
                    n_high_vif_2713 = sum(1 for r in vif_rows_2713 if r["vif_category"] == "high")
                    vif_status_2713 = "OK" if n_high_vif_2713 == 0 else "WARN"
                    vif_detail_2713 = str(vif_path_2713)
                else:
                    vif_status_2713 = "FAIL"
            else:
                print("   ‚ö†Ô∏è Insufficient numeric columns")
                vif_status_2713 = "WARN"

# Diagnostics
summary_2713 = pd.DataFrame([{
    "section": "2.7.13", "section_name": "Multicollinearity check (VIF)",
    "check": "Compute VIFs to detect redundant predictors",
    "level": "info", "n_columns_evaluated": n_cols_eval_2713,
    "n_high_vif": n_high_vif_2713, "status": vif_status_2713,
    "detail": vif_detail_2713,
    "notes": f"VIF>{multi_max_vif_2713} columns flagged for removal"
}])

# Append & display (assuming these functions exist)
try:
    append_sec2(summary_2713, SECTION2_REPORT_PATH)
    display(summary_2713)
except:
    print(summary_2713)

2.7.13 | Multicollinearity Check (VIF)
   üìä Numeric cols for VIF: 7 - ['SeniorCitizen', 'tenure', 'MonthlyCharges', 'TotalCharges', 'Churn_flag', 'Senior_flag', '_logic_repair_applied']
   ‚ùå VIF failed: ufunc 'isfinite' not supported for the input types, and the inputs could not be safely coerced to any supported types according to the casting rule ''safe''
üßæ Appended diagnostics ‚Üí /Users/b/DATA/PROJECTS/Telco/_T2/Level_3/runs/20260122_183125/reports/section2_unified.csv
```

That error is coming from **this exact line**:

```python
if np.isfinite(vif_val):
```

`np.isfinite()` only works on real numeric types. In your run, `vif_val` was **not a plain float** ‚Äî it was an ‚Äúobject-y‚Äù thing (commonly a `Decimal`, a `numpy.object_`, or something produced because the underlying matrix ended up with an `object` dtype). When `np.isfinite()` sees that, it throws:

> ufunc 'isfinite' not supported for the input types ‚Ä¶

So the real culprit isn‚Äôt ‚ÄúVIF math‚Äù ‚Äî it‚Äôs **dtype contamination** in the exogenous matrix being used for VIF.

### Why your matrix got contaminated

Your `candidate_cols` are chosen using `is_numeric_dtype`, which will happily treat a bunch of *flag columns* as numeric-ish:

* `Churn_flag`
* `Senior_flag`
* `_logic_repair_applied`

Those are often `bool`, pandas‚Äô nullable `boolean`, or even `object` depending on how they were created/filled earlier. Even if `select_dtypes(include=[np.number])` drops some of them, the remaining DataFrame can still carry **nullable extension dtypes** (like `Int64`, `Float64`, `boolean`) that sometimes cause `.values` to become an `object` array downstream. Once that happens, statsmodels can return a VIF value that isn‚Äôt a clean float, and `np.isfinite()` detonates.

### The ‚Äúbulletproof‚Äù fix (make the VIF matrix truly float)

Right before computing VIF, force the design matrix to a real `float64` numpy array, and drop degenerate columns:

```python
X = df_27[candidate_cols].copy().dropna()

# keep only numeric, then FORCE float
X_numeric = X.apply(pd.to_numeric, errors="coerce")
X_numeric = X_numeric.fillna(X_numeric.mean(numeric_only=True))

# drop constant / near-constant columns (VIF is meaningless there)
nunique = X_numeric.nunique(dropna=True)
X_numeric = X_numeric.loc[:, nunique > 1]

if X_numeric.shape[1] >= 2:
    X_with_const = sm.add_constant(X_numeric, has_constant="add")

    # ‚úÖ force a real float ndarray so everything downstream is numeric
    exog = X_with_const.to_numpy(dtype="float64")

    vif_vals = []
    for i, col in enumerate(X_with_const.columns[1:], 1):
        vif_val = float(variance_inflation_factor(exog, i))  # ‚úÖ force float
        vif_vals.append((col, vif_val))
        print(f"   ‚úÖ {col}: VIF={vif_val:.2f}")
```

And now you don‚Äôt even need `np.isfinite()`‚Äîbut if you keep it, it will work because `vif_val` is guaranteed `float`.

### Extra sanity guard (stop flags from entering VIF)

If you *don‚Äôt* want binary flags to be part of VIF (often a good idea), filter them out:

```python
from pandas.api.types import is_bool_dtype

candidate_cols = [
    c for c in df_27.columns
    if is_numeric_dtype(df_27[c]) and not is_bool_dtype(df_27[c])
]
```

That would automatically kick out `Churn_flag`, `Senior_flag`, `_logic_repair_applied` if they‚Äôre boolean-like.

Bottom line: your VIF failed because **something in the VIF pipeline wasn‚Äôt a real float**, and `np.isfinite()` is the first place that fact became undeniable. Casting the matrix to `float64` (and optionally excluding boolean flags) will make this section stable.
