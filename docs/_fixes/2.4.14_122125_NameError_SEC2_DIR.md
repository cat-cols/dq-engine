
```python
# 2.4.14 | Dashboard & Alert Integration
print("\n2.4.14 üì∫ Dashboard & alert integration")

# Convention:
# - SEC2_DIR = global "latest" artifacts (cross-section inputs)
# - SEC2_24_DIR = section-owned artifacts (2.4.x outputs)
# - Publish step copies section-owned outputs -> SEC2_DIR for other sections
# --------------------------------------------------------------------
# Section 2 unified diagnostics CSV
# SECTION2_REPORT_PATH  # (a file)
# and/or
# SEC2_REPORTS_DIR       # (a folder)

# Paths for inputs we might use globally
run_health_path_2414            = SEC2_DIR / "run_health_summary.csv"
numeric_drift_metrics_path_2414 = SEC2_DIR / "data_drift_metrics.csv"
model_ready_path_2414           = SEC2_DIR / "model_readiness_report.csv"
dashboard_alerts_latest_path    = SEC2_DIR / "dashboard_alerts.json"


# local
issues_index_path_2414 = CATEGORICAL_DIR / "categorical_domain_issues_catalog" / "issues_index.csv"
cat_profile_path_2414 = CATEGORICAL_DIR / "categorical_profile_df.csv"
cat_drift_path_2414 = CATEGORICAL_DIR / "category_drift_report.csv"
dashboard_alerts_path_2414 = SEC2_24_DIR / "dashboard_alerts.json"
dashboard_alerts_tmp_2414 = dashboard_alerts_path_2414.with_suffix(".tmp.json")

# Optional: publish a global "latest" pointer for other sections
dashboard_alerts_latest_path = SEC2_DIR / "dashboard_alerts.json"


# --------------------------------------------------------------------
# 0) Safety defaults for thresholds (if not already set upstream)
# --------------------------------------------------------------------
if "drift_high_threshold_2414" not in globals():
    drift_high_threshold_2414 = 0  # any high-drift column will trigger

if "low_ready_threshold_2414" not in globals():
    low_ready_threshold_2414 = 0  # any low-readiness feature will trigger

# --------------------------------------------------------------------
# 1) Load Section 2 summary for overall status tile
# --------------------------------------------------------------------
sec2_summary_df_2414 = pd.DataFrame()
if SECTION2_REPORT_PATH.exists():
    try:
        sec2_summary_df_2414 = pd.read_csv(SECTION2_REPORT_PATH)
    except Exception:
        sec2_summary_df_2414 = pd.DataFrame()

overall_status_2414 = "OK"
if not sec2_summary_df_2414.empty and "status" in sec2_summary_df_2414.columns:
    _statuses_2414 = sec2_summary_df_2414["status"].astype(str).str.upper().tolist()
    if any(s == "FAIL" for s in _statuses_2414):
        overall_status_2414 = "FAIL"
    elif any(s == "WARN" for s in _statuses_2414):
        overall_status_2414 = "WARN"
    elif any(s == "INFO" for s in _statuses_2414):
        overall_status_2414 = "INFO"
    else:
        overall_status_2414 = "OK"

# --------------------------------------------------------------------
# 2) Numeric health metrics
# --------------------------------------------------------------------
numeric_drift_high_2414 = 0
contracts_hard_fail_2414 = 0
numeric_status_tile_2414 = overall_status_2414

if run_health_path_2414.exists():
    try:
        run_health_df_2414 = pd.read_csv(run_health_path_2414)
        if "n_high_drift_columns" in run_health_df_2414.columns:
            numeric_drift_high_2414 = int(run_health_df_2414["n_high_drift_columns"].iloc[0])
        if "contracts_hard_fail" in run_health_df_2414.columns:
            contracts_hard_fail_2414 = int(run_health_df_2414["contracts_hard_fail"].iloc[0])
        if "numeric_status" in run_health_df_2414.columns:
            numeric_status_tile_2414 = str(run_health_df_2414["numeric_status"].iloc[0])
    except Exception:
        pass

# --------------------------------------------------------------------
# 3) Categorical issues index
# --------------------------------------------------------------------
issues_index_df_2414 = pd.DataFrame()
n_critical_issue_types_2414 = 0
if issues_index_path_2414.exists():
    try:
        issues_index_df_2414 = pd.read_csv(issues_index_path_2414)
        if "has_critical" in issues_index_df_2414.columns:
            n_critical_issue_types_2414 = int(
                issues_index_df_2414["has_critical"].fillna(False).astype(bool).sum()
            )
    except Exception:
        pass

# --------------------------------------------------------------------
# 4) Categorical profile
# --------------------------------------------------------------------
cat_profile_df_2414 = pd.DataFrame()
n_cat_critical_2414 = 0
if cat_profile_path_2414.exists():
    try:
        cat_profile_df_2414 = pd.read_csv(cat_profile_path_2414)
        if "cat_severity" in cat_profile_df_2414.columns:
            n_cat_critical_2414 = int(
                cat_profile_df_2414["cat_severity"].astype(str).str.lower().eq("critical").sum()
            )
    except Exception:
        pass

# --------------------------------------------------------------------
# 5) Model readiness report (2.4.13 output)
# --------------------------------------------------------------------
model_ready_df_2414 = pd.DataFrame()
n_model_low_ready_2414 = 0
if model_ready_path_2414.exists():
    try:
        model_ready_df_2414 = pd.read_csv(model_ready_path_2414)
        if "readiness_label" in model_ready_df_2414.columns:
            n_model_low_ready_2414 = int(
                model_ready_df_2414["readiness_label"].astype(str).str.lower().eq("low").sum()
            )
    except Exception:
        pass

# --------------------------------------------------------------------
# 6) Categorical drift metrics
# --------------------------------------------------------------------
cat_drift_high_cols_2414 = 0
if cat_drift_path_2414.exists():
    try:
        cat_drift_df_2414 = pd.read_csv(cat_drift_path_2414)
        if "drift_severity" in cat_drift_df_2414.columns:
            _high_drift_cols_2414 = (
                cat_drift_df_2414.loc[
                    cat_drift_df_2414["drift_severity"].astype(str).str.lower().eq("high"),
                    "column",
                ]
                .dropna()
                .unique()
            )
            cat_drift_high_cols_2414 = int(len(_high_drift_cols_2414))
    except Exception:
        pass

# 7) Determine RUN_ID and timestamp for this run
now_utc_2414 = datetime.now(timezone.utc)

if "RUN_ID" in globals():
    run_id_2414 = RUN_ID
else:
    run_id_2414 = f"sec2_{now_utc_2414.strftime('%Y%m%dT%H%M%SZ')}"
    RUN_ID = run_id_2414


# 8) Build alerts list based on thresholds and earlier diagnostics
alerts_2414 = []

# Numeric drift alert
if numeric_drift_high_2414 > drift_high_threshold_2414:
    alerts_2414.append(
        {
            "alert_id": "numeric_high_drift",
            "severity": "warn",
            "message": f"{numeric_drift_high_2414} numeric columns show high drift (>{drift_high_threshold_2414}).",
            "section_refs": "2.3.14",
            "artifact_hint": str(numeric_drift_metrics_path_2414.name),
        }
    )

# Categorical drift alert
if cat_drift_high_cols_2414 > drift_high_threshold_2414:
    alerts_2414.append(
        {
            "alert_id": "categorical_high_drift",
            "severity": "warn",
            "message": f"{cat_drift_high_cols_2414} categorical columns show high drift (>{drift_high_threshold_2414}).",
            "section_refs": "2.4.11",
            "artifact_hint": str(cat_drift_path_2414.name),
        }
    )

# Contract failures alert
if contracts_hard_fail_2414 > 0:
    alerts_2414.append(
        {
            "alert_id": "data_contract_failure",
            "severity": "critical",
            "message": f"{contracts_hard_fail_2414} hard data contract failures detected.",
            "section_refs": "2.3.16",
            "artifact_hint": "data_contract_violations.json",
        }
    )

# Categorical domain issues (invalid tokens, unexpected values, etc.)
if n_critical_issue_types_2414 > 0:
    alerts_2414.append(
        {
            "alert_id": "categorical_domain_issues",
            "severity": "warn",
            "message": f"{n_critical_issue_types_2414} categorical issue types flagged as critical.",
            "section_refs": "2.4.1‚Äì2.4.7",
            "artifact_hint": "categorical_domain_issues_catalog/issues_index.csv",
        }
    )

# Categorical severity from profile
if n_cat_critical_2414 > 0:
    alerts_2414.append(
        {
            "alert_id": "categorical_critical_features",
            "severity": "warn",
            "message": f"{n_cat_critical_2414} categorical features have cat_severity='critical'.",
            "section_refs": "2.4.12",
            "artifact_hint": str(cat_profile_path_2414.name),
        }
    )

# Low model readiness features
if n_model_low_ready_2414 > low_ready_threshold_2414:
    alerts_2414.append(
        {
            "alert_id": "low_model_readiness",
            "severity": "warn",
            "message": f"{n_model_low_ready_2414} model-facing categorical features have low readiness.",
            "section_refs": "2.4.13",
            "artifact_hint": str(model_ready_path_2414.name),
        }
    )

# 9) Build summary tiles for dashboards
numeric_tile_status_2414 = numeric_status_tile_2414
if contracts_hard_fail_2414 > 0:
    numeric_tile_status_2414 = "FAIL"
elif numeric_drift_high_2414 > drift_high_threshold_2414 and numeric_tile_status_2414 == "OK":
    numeric_tile_status_2414 = "WARN"

categorical_tile_status_2414 = "OK"
if (
    n_cat_critical_2414 > 0
    or n_critical_issue_types_2414 > 0
    or cat_drift_high_cols_2414 > drift_high_threshold_2414
):
    categorical_tile_status_2414 = "WARN"

model_ready_tile_status_2414 = "OK"
if n_model_low_ready_2414 > low_ready_threshold_2414:
    model_ready_tile_status_2414 = "WARN"

summary_tiles_2414 = {
    "numeric_health": {
        "status": numeric_tile_status_2414,
        "metrics": {
            "n_high_drift_columns": numeric_drift_high_2414,
            "contracts_hard_fail": contracts_hard_fail_2414,
        },
    },
    "categorical_health": {
        "status": categorical_tile_status_2414,
        "metrics": {
            "n_categorical_critical_features": n_cat_critical_2414,
            "n_critical_issue_types": n_critical_issue_types_2414,
            "n_high_drift_categorical_columns": cat_drift_high_cols_2414,
        },
    },
    "model_readiness": {
        "status": model_ready_tile_status_2414,
        "metrics": {
            "n_low_readiness_features": n_model_low_ready_2414,
        },
    },
}

dashboard_payload_2414 = {
    "run_id": run_id_2414,
    "section2_overall_status": overall_status_2414,
    "created_at_utc": now_utc_2414.isoformat(),
    "summary_tiles": summary_tiles_2414,
    "alerts": alerts_2414,
}

# does this belong here?
shutil.copy2(local_path, SEC2_DIR / local_path.name)


# 10) Write JSON atomically
try:
    dashboard_alerts_path_2414.parent.mkdir(parents=True, exist_ok=True)
    with open(dashboard_alerts_tmp_2414, "w", encoding="utf-8") as _f:
        json.dump(dashboard_payload_2414, _f, indent=2, sort_keys=True)
    os.replace(dashboard_alerts_tmp_2414, dashboard_alerts_path_2414)
    try:
        import shutil
        shutil.copy2(dashboard_alerts_path_2414, dashboard_alerts_latest_path)
    except Exception:
        pass
except Exception:
    if dashboard_alerts_tmp_2414.exists():
        dashboard_alerts_tmp_2414.unlink()

n_alerts_2414 = len(alerts_2414)
n_critical_alerts_2414 = sum(
    1 for _a in alerts_2414 if _a.get("severity", "").lower() == "critical"
)

status_2414 = "OK"
if not dashboard_alerts_path_2414.exists():
    status_2414 = "WARN"

summary_2414 = pd.DataFrame([{
            "section": "2.4.14",
            "section_name": "Dashboard & alert integration",
            "check": "Surface Section 2 numeric + categorical health into a single JSON for dashboards/alerts",
            "level": "info",
            "status": status_2414,
            "n_alerts": int(n_alerts_2414),
            "n_critical_alerts": int(n_critical_alerts_2414),
            "detail": "dashboard_alerts.json",
            "timestamp": pd.Timestamp.utcnow(),
        }])

append_sec2(summary_2414, SECTION2_REPORT_PATH)

display(summary_2414)

print(f"üíæ 2.4.14 dashboard_alerts.json ‚Üí {dashboard_alerts_path_2414}")
print(f"   alerts: {n_alerts_2414} (critical: {n_critical_alerts_2414})")

---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
Cell In[163], line 17
      2 print("\n2.4.14 üì∫ Dashboard & alert integration")
      4 # Convention:
      5 # - SEC2_DIR = global "latest" artifacts (cross-section inputs)
      6 # - SEC2_24_DIR = section-owned artifacts (2.4.x outputs)
   (...)     15 
     16 # Paths for inputs we might use globally
---> 17 run_health_path_2414            = SEC2_DIR / "run_health_summary.csv"
     18 numeric_drift_metrics_path_2414 = SEC2_DIR / "data_drift_metrics.csv"
     19 model_ready_path_2414           = SEC2_DIR / "model_readiness_report.csv"

NameError: name 'SEC2_DIR' is not defined
```

># SOLUTION

You‚Äôre hitting the classic notebook problem: **you‚Äôre relying on a ‚Äúglobal latest artifacts directory‚Äù (`SEC2_DIR`) but you never define it in the bootstrap.** So later sections explode with `NameError`.

If you want a **best long-term solution without using functions**, the answer is:

### ‚úÖ Establish a single ‚ÄúSection 2 shared (latest) artifacts folder‚Äù as a *contract* in the bootstrap, and never deviate.

You already have:

* `SEC2_REPORTS_DIR` (folder)
* `SEC2_ARTIFACTS_DIR` (folder)
* `SEC2_ARTIFACT_DIRS["2.4"]` (per-section folder)

What you *don‚Äôt* have is a canonical **shared** ‚Äúlatest‚Äù folder. That‚Äôs what `SEC2_DIR` is trying to be.

---

## Best long-term, no-functions solution

### 1) Define `SEC2_DIR` once in bootstrap (Part 5 or Part 6)

Right after you define `SEC2_ARTIFACTS_DIR`, add:

```python
# ---- Canonical "latest shared" Section 2 artifacts folder (cross-section inputs) ----
# This is where sections publish "latest" artifacts for other sections to consume.
SEC2_DIR = globals().get("SEC2_DIR", (SEC2_ARTIFACTS_DIR / "_latest").resolve())
SEC2_DIR.mkdir(parents=True, exist_ok=True)
print("üìÅ SEC2_DIR (shared latest):", SEC2_DIR)
```

That alone fixes your `NameError` forever.

---

### 2) Define `SEC2_24_DIR` (section-owned outputs) explicitly in 2.4.14

Your 2.4.14 assumes `SEC2_24_DIR` exists. Make it deterministic:

```python
SEC2_24_DIR = globals().get("SEC2_24_DIR", SEC2_ARTIFACT_DIRS["2.4"])
SEC2_24_DIR.mkdir(parents=True, exist_ok=True)
print("üìÅ SEC2_24_DIR (2.4 owned):", SEC2_24_DIR)
```

Now your ‚Äútwo-tier artifact model‚Äù is stable:

* `SEC2_24_DIR` = outputs created by 2.4.x
* `SEC2_DIR` = published ‚Äúlatest‚Äù outputs for other sections

---

### 3) Replace your ‚Äúpublish‚Äù line with a plain inline block (no function)

This line:

```python
shutil.copy2(local_path, SEC2_DIR / local_path.name)
```

does **not** belong where you put it because `local_path` isn‚Äôt defined, and you only need to publish **after** the file is actually written successfully.

Put this **after** the atomic write succeeds:

```python
# publish "latest" copy for other sections (best-effort)
try:
    import shutil
    shutil.copy2(dashboard_alerts_path_2414, SEC2_DIR / dashboard_alerts_path_2414.name)
except Exception:
    pass
```

That‚Äôs enough. No function needed.

---

## What should `SEC2_DIR` be: reports dir or report path?

**Neither.**

* `SECTION2_REPORT_PATH` is a **single CSV file** (unified diagnostics)
* `SEC2_REPORTS_DIR` is a **reports folder**
* `SEC2_DIR` should be a **shared artifacts folder**, not reports

So the best convention is:

* `SEC2_DIR = SEC2_ARTIFACTS_DIR / "_latest"`
* **not** `SEC2_REPORTS_DIR`
* **not** `SECTION2_REPORT_PATH`

Because ‚Äúlatest inputs‚Äù are *artifacts* (JSON/CSV outputs from other sections), not the unified diagnostics log.

---

## Minimal patch to your 2.4.14 cell (no functions)

Add this near the top of 2.4.14, before you build paths:

```python
# --- Guards / Resolve shared dirs ---
assert "SEC2_ARTIFACTS_DIR" in globals(), "‚ùå SEC2_ARTIFACTS_DIR missing. Run bootstrap Part 5."
assert "SEC2_ARTIFACT_DIRS" in globals(), "‚ùå SEC2_ARTIFACT_DIRS missing. Run bootstrap Part 6."

SEC2_DIR = globals().get("SEC2_DIR", (SEC2_ARTIFACTS_DIR / "_latest").resolve())
SEC2_DIR.mkdir(parents=True, exist_ok=True)

SEC2_24_DIR = globals().get("SEC2_24_DIR", SEC2_ARTIFACT_DIRS["2.4"])
SEC2_24_DIR.mkdir(parents=True, exist_ok=True)
```

Then your existing lines like:

```python
run_health_path_2414 = SEC2_DIR / "run_health_summary.csv"
```

will work reliably.

---

## Why this is the ‚Äúbest long-term‚Äù notebook approach

* **No functions needed**
* **No reliance on ‚Äúcell order memory‚Äù** beyond running bootstrap once
* **One stable contract** for cross-section I/O: `SEC2_DIR/_latest`
* Avoids the ‚Äútruth conflict‚Äù issue you already identified: *section-owned outputs vs shared published outputs*

---

If you want, I can point out the *exact* place in your bootstrap where `SEC2_DIR` should be defined so it‚Äôs guaranteed available for every subsequent section (it‚Äôs one line in Part 5 right after `SEC2_ARTIFACTS_DIR`).
