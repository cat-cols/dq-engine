# 2.0.7.6.1) Annotate nodes with uses_append_sec2 based on actual usage

Why choose one over the other? which one is better

Theyâ€™re doing **different jobs**:

### Option A

```python
append_sections = globals().get("SECTION2_APPEND_SECTIONS", set())
```

**Keeps whatever type you already have** in `SECTION2_APPEND_SECTIONS` (usually a `set`).

* âœ… Best if you only need: `len(append_sections)` or `append_sections.add(...)`
* âœ… Preserves ints/strings/etc. as-is
* âŒ If someone accidentally stored `{"2.0.1": True}` (dict) or a list with non-strings, your later `sec in append_sections` comparisons can get weird

### Option B

```python
append_sections = {str(s) for s in globals().get("SECTION2_APPEND_SECTIONS", set())}
```

**Normalizes everything to strings**.

* âœ… Best if your node sections are strings like `"2.0.1"` and you want membership checks to be reliable:

  ```python
  node["uses_append_sec2"] = node["section"] in append_sections
  ```
* âœ… Protects you if someone did `SECTION2_APPEND_SECTIONS.add(2.01)` or `add(201)` or other non-string junk
* âŒ Slightly more work (tiny) and you lose original types (usually not needed)

---

## Which is better?

For your use case (annotating nodes + stable registry): **Option B is better**.

Youâ€™re comparing:

* `sec = str(node.get("section"))` (string)
* against `append_sections`

So making `append_sections` a **set of strings** guarantees the comparison behaves.

---

## Best practice: do both, but with different names

This avoids overwriting and keeps intent clear:

```python
append_sections_raw = globals().get("SECTION2_APPEND_SECTIONS", set())
append_sections_str = {str(s) for s in append_sections_raw}
```

Then:

* use `append_sections_str` for `uses_append_sec2`
* use `append_sections_raw` only if you truly need the original type (you probably donâ€™t)

ğŸ’¡ğŸ’¡ Also: if you want to be extra safe against `None`, do:

```python
append_sections_raw = globals().get("SECTION2_APPEND_SECTIONS") or set()
append_sections_str = {str(s) for s in append_sections_raw}
```

># 12/21/25

Got you. Hereâ€™s a **step-by-step â€œfix listâ€** for *each issue that still exists in this script*, in the order Iâ€™d fix them in a notebook.

---

## Step 1 â€” Fix the dataset version registry path mismatch ğŸš¨

### Whatâ€™s wrong

You set:

```python
version_registry_path = REGISTRY_DIR / "dataset_version_registry.csv"
```

But earlier youâ€™ve had **two different REGISTRY_DIR meanings** (section2-scoped vs project-wide). Thatâ€™s exactly why you got â€œnot foundâ€.

### Fix

**Choose one canonical path** (recommended: the one defined in bootstrap: `DATASET_VERSION_REGISTRY_PATH`) and use only that here.

âœ… Change this whole block to:

```python
version_id_for_registry = globals().get("version_id", None)

DATASET_VERSION_REGISTRY_PATH = globals().get(
    "DATASET_VERSION_REGISTRY_PATH",
    (Path(ARTIFACTS_DIR) / "registry" / "dataset_version_registry.csv").resolve()
)

if version_id_for_registry is None and DATASET_VERSION_REGISTRY_PATH.exists():
    try:
        reg_df = pd.read_csv(DATASET_VERSION_REGISTRY_PATH)
        if not reg_df.empty and "version_id" in reg_df.columns:
            version_id_for_registry = str(reg_df["version_id"].iloc[-1])
    except Exception:
        pass
```

ğŸ’¡ğŸ’¡ **Also add** `dataset_version_registry_path` into your registry payload so you can debug path truth later.

---

## Step 2 â€” Remove the duplicated `append_sections` variants (pick ONE) ğŸ§¹

### Whatâ€™s wrong

You compute 3 variants but only use one:

```python
append_sections = ...
append_sections_raw = ...
append_sections_str = ...
```

This makes it easy to accidentally use the wrong one later.

### Fix (best)

Keep the most robust pattern:

```python
append_sections_raw = globals().get("SECTION2_APPEND_SECTIONS") or set()
append_sections = {str(s) for s in append_sections_raw}
n_sections_append_sec2 = len(append_sections)
```

âœ… Delete the other two lines entirely.

---

## Step 3 â€” Fix the helper call `summarize_append_refactor` (wrong signature + missing args) ğŸš¨

### Whatâ€™s wrong

You call it like:

```python
refactor_summary = summarize_append_refactor(
    old_block_lines=37,
    call_lines=1,
    helper_lines=45,
)
```

But earlier you showed it expects at least `n_sections=...` (and maybe more). Also: you **never use** `refactor_summary` after computing it.

### Fix options

Pick one:

#### Option A (simplest): remove it entirely âœ…

If youâ€™re not using it, drop the whole helper section.

#### Option B: keep it, but correctly + actually use it ğŸ’¡ğŸ’¡

Replace with:

```python
refactor_summary = None
if "summarize_append_refactor" in globals() and callable(summarize_append_refactor):
    refactor_summary = summarize_append_refactor(
        n_sections=n_sections_append_sec2,
        old_block_lines=old_block_lines,
        call_lines=call_lines,
        helper_lines=45,
    )
```

And then in `engineering_metrics` use it:

```python
engineering_metrics = {
    "duplicated_code_eliminated": (
        refactor_summary["loc_saved"] if refactor_summary else loc_saved
    ),
    "helper_functions_created": 1,
    "sections_modularized": (
        refactor_summary["n_sections"] if refactor_summary else n_sections_append_sec2
    ),
    "notebook_cells_reduced": None,
}
```

---

## Step 4 â€” Make timestamps consistent (UTC) â±ï¸

### Whatâ€™s wrong

You write:

```python
"timestamp": [pd.Timestamp.now()],
```

That is local time (and sometimes tz-naive).

### Fix

Use UTC consistently:

```python
"timestamp": [pd.Timestamp.utcnow()],
```

ğŸ’¡ğŸ’¡ Same for any other â€œnow()â€ you put into artifacts.

---

## Step 5 â€” Fix `pipeline_steps_automated` logic (itâ€™s fine, but make it robust) âœ…

### Whatâ€™s wrong

This is *not broken*, but itâ€™s defensive in a weird way now:

```python
pipeline_steps_automated = len(section2_nodes) if isinstance(section2_nodes, list) else None
```

Since we control `section2_nodes`, it should always be a list.

### Fix (optional clean)

Replace with:

```python
pipeline_steps_automated = len(section2_nodes)
```

ğŸ’¡ğŸ’¡ If this ever becomes non-list again, you want it to crash loudly because thatâ€™s a real bug.

---

## Step 6 â€” Add guards so the cell fails early (instead of writing garbage) ğŸš¨

### Whatâ€™s wrong

This cell assumes a ton of globals exist:
`df, PROJECT_ROOT, LEVEL_ROOT, SEC2_REPORTS_DIR, ...`

If one is missing, youâ€™ll get a confusing error halfway through.

### Fix

At the top, add:

```python
required = ["df", "PROJECT_ROOT", "LEVEL_ROOT", "REPORTS_DIR", "ARTIFACTS_DIR", "SEC2_REPORTS_DIR", "SEC2_ARTIFACTS_DIR", "SECTION2_REPORT_PATH"]
missing = [k for k in required if k not in globals()]
if missing:
    raise RuntimeError(f"âŒ 2.0.7 missing required globals: {missing}")
```

ğŸ’¡ğŸ’¡ This saves you from â€œmystery Noneâ€ problems later.

---

## Step 7 â€” Make `REGISTRY_DIR` meaning unambiguous ğŸ§ 

### Whatâ€™s wrong

Right now your payload includes:

```python
"registry_dir": str(REGISTRY_DIR),
```

But youâ€™ve had **multiple interpretations** of `REGISTRY_DIR`. This is the â€œsingle source of truthâ€ trap you mentioned.

### Fix

In the payload, include both:

* `registry_dir` (whatever is current)
* `dataset_version_registry_path` (actual file you used)

Add:

```python
"dataset_version_registry_path": str(DATASET_VERSION_REGISTRY_PATH),
```

Now you can always see what it really used.

---

## Step 8 â€” Small clarity: the â€œNOTE annotate nodesâ€ comment is mislabeled ğŸ§¾

### Whatâ€™s wrong

This comment is attached to the future sections append loop:

```python
# 2.0.7.6.1 Annotate nodes with uses_append_sec2 based on actual usage
for sec, name, deps in future_sections:
    section2_nodes.append(...)
```

But that loop is NOT annotating nodes; itâ€™s **adding future nodes**.

### Fix

Rename comment to something accurate:

```python
# 2.0.7.5 Add placeholder nodes for 2.1â€“2.9
```

Then keep the annotation comment where you actually annotate.

---

# Minimal â€œpatchâ€ summary (do these 5 edits first)

If you only do the essentials:

1. âœ… Use `DATASET_VERSION_REGISTRY_PATH` instead of `REGISTRY_DIR / ...`
2. âœ… Delete duplicate append_sections variants; keep one
3. âœ… Fix or remove `summarize_append_refactor` block
4. âœ… Use `pd.Timestamp.utcnow()` not `.now()`
5. âœ… Add early guards for required globals

---

## ğŸ’¡ğŸ’¡ Quick reality check: what error are you seeing right now?

If you paste the traceback, I can point to the exact lineâ€”BUT even without it, the issues above are the ones that will most reliably cause runtime failure or silent wrong outputs.
