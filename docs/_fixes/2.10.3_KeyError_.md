```python
# 2.10.3 | Visual Univariate Profiles
print("2.10.3 ‚ñ∂ Visual Univariate Profiles")

default_univariate_vis_cfg = {
    "ENABLED": True,
    "OUTPUT_DIR": str(figures_root_210),
    "MAX_NUMERIC_PLOTS": 40,
    "MAX_CATEGORICAL_PLOTS": 40,
}
univariate_vis_cfg = _get_cfg_210("UNIVARIATE_VISUALS", default_univariate_vis_cfg)

univ_vis_enabled_2103 = bool(univariate_vis_cfg.get("ENABLED", True))
univ_vis_output_dir_2103 = Path(univariate_vis_cfg.get("OUTPUT_DIR", str(figures_root_210))).resolve()
max_num_numeric_2103 = int(univariate_vis_cfg.get("MAX_NUMERIC_PLOTS", 40))
max_num_categorical_2103 = int(univariate_vis_cfg.get("MAX_CATEGORICAL_PLOTS", 40))

(univ_vis_output_dir_2103 / "numeric").mkdir(parents=True, exist_ok=True)
(univ_vis_output_dir_2103 / "categorical").mkdir(parents=True, exist_ok=True)

visual_index_rows_2103 = []

n_plots_numeric_2103 = 0
n_plots_categorical_2103 = 0

if univ_vis_enabled_2103:
    # Use summaries if available to prioritize; otherwise fall back to basic lists
    numeric_cols_for_plots_2103 = []
    if not num_summary_df_2101.empty:
        numeric_cols_for_plots_2103 = list(num_summary_df_2101["feature"])
    else:
        from pandas.api.types import is_numeric_dtype

        numeric_cols_for_plots_2103 = [c for c in df_clean.columns if is_numeric_dtype(df_clean[c])]

    categorical_cols_for_plots_2103 = []
    if not cat_summary_df_2102.empty:
        categorical_cols_for_plots_2103 = list(cat_summary_df_2102["feature"])
    else:
        from pandas.api.types import is_numeric_dtype

        categorical_cols_for_plots_2103 = [c for c in df_clean.columns if not is_numeric_dtype(df_clean[c])]

    # Limit counts
    numeric_cols_for_plots_2103 = numeric_cols_for_plots_2103[:max_num_numeric_2103]
    categorical_cols_for_plots_2103 = categorical_cols_for_plots_2103[:max_num_categorical_2103]

    # Numeric plots
    for col in numeric_cols_for_plots_2103:
        s = df_clean[col].dropna()
        if s.empty:
            continue

        fig, ax = plt.subplots(figsize=(5, 3))
        ax.hist(s, bins=30, alpha=0.8)
        ax.set_title(f"{col} ‚Äì Histogram")
        ax.set_xlabel(col)
        ax.set_ylabel("Count")

        plot_path = (univ_vis_output_dir_2103 / "numeric" / f"{col}_hist.png").resolve()
        fig.tight_layout()
        fig.savefig(plot_path)
        plt.close(fig)

        visual_index_rows_2103.append(
            {
                "feature": col,
                "kind": "numeric_histogram",
                "path": str(plot_path),
            }
        )
        n_plots_numeric_2103 += 1

    # Categorical plots
    for col in categorical_cols_for_plots_2103:
        s = df_clean[col].astype("object")
        s_non_null = s[s.notna()]
        if s_non_null.empty:
            continue

        vc = s_non_null.value_counts().head(30)  # cap to top 30 for clarity

        fig, ax = plt.subplots(figsize=(6, 3.5))
        vc.plot(kind="bar", ax=ax)
        ax.set_title(f"{col} ‚Äì Category Counts (top 30)")
        ax.set_xlabel(col)
        ax.set_ylabel("Count")
        plt.xticks(rotation=45, ha="right")

        plot_path = (univ_vis_output_dir_2103 / "categorical" / f"{col}_bar.png").resolve()
        fig.tight_layout()
        fig.savefig(plot_path)
        plt.close(fig)

        visual_index_rows_2103.append(
            {
                "feature": col,
                "kind": "categorical_bar",
                "path": str(plot_path),
            }
        )
        n_plots_categorical_2103 += 1

# Create optional index CSV
univ_vis_index_path_2103 = section2_reports_dir_210 / "univariate_visual_index.csv"
if visual_index_rows_2103:
    vis_idx_df_2103 = pd.DataFrame(visual_index_rows_2103)
    tmp_2103 = univ_vis_index_path_2103.with_suffix(".tmp.csv")
    vis_idx_df_2103.to_csv(tmp_2103, index=False)
    os.replace(tmp_2103, univ_vis_index_path_2103)
else:
    vis_idx_df_2103 = pd.DataFrame(columns=["feature", "kind", "path"])

# Diagnostics row for 2.10.3
if (n_plots_numeric_2103 + n_plots_categorical_2103) == 0 and univ_vis_enabled_2103:
    status_2103 = "WARN"
else:
    status_2103 = "OK"

sec2_chunk_2103 = pd.DataFrame(
    {
        "section": ["2.10.3"],
        "section_name": ["Visual univariate profiles"],
        "check": ["Generate histograms and bar plots for prioritized features"],
        "level": ["info"],
        "n_plots_numeric": [n_plots_numeric_2103],
        "n_plots_categorical": [n_plots_categorical_2103],
        "status": [status_2103],
        "detail": [str(univ_vis_output_dir_2103)],
    }
)

if "_append_sec2" in globals() and callable(_append_sec2):
    _append_sec2(sec2_chunk_2103)
else:
    print("‚ÑπÔ∏è _append_sec2 not available; 2.10.3 diagnostics not appended to Section 2 report.")

print("‚úÖ 2.10A complete ‚Äî numeric & categorical univariate summaries + visuals generated.")


--------------------------------------------------------------------
> KeyError                                  Traceback (most recent call last)
File ~/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/numpy/lib/_histograms_impl.py:345, in _unsigned_subtract(a, b)
    344 try:
--> 345     unsigned_dt = signed_to_unsigned[dt.type]
    346 except KeyError:

KeyError: <class 'numpy.bool'>

During handling of the above exception, another exception occurred:

TypeError                                 Traceback (most recent call last)
Cell In[199], line 54
     51     continue
     53 fig, ax = plt.subplots(figsize=(5, 3))
---> 54 ax.hist(s, bins=30, alpha=0.8)
     55 ax.set_title(f"{col} ‚Äì Histogram")
     56 ax.set_xlabel(col)

File ~/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/matplotlib/_api/deprecation.py:453, in make_keyword_only.<locals>.wrapper(*args, **kwargs)
    447 if len(args) > name_idx:
    448     warn_deprecated(
    449         since, message="Passing the %(name)s %(obj_type)s "
    450         "positionally is deprecated since Matplotlib %(since)s; the "
    451         "parameter will become keyword-only in %(removal)s.",
    452         name=name, obj_type=f"parameter of {func.__name__}()")
--> 453 return func(*args, **kwargs)

File ~/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/matplotlib/__init__.py:1524, in _preprocess_data.<locals>.inner(ax, data, *args, **kwargs)
   1521 @functools.wraps(func)
   1522 def inner(ax, *args, data=None, **kwargs):
   1523     if data is None:
-> 1524         return func(
   1525             ax,
   1526             *map(cbook.sanitize_sequence, args),
   1527             **{k: cbook.sanitize_sequence(v) for k, v in kwargs.items()})
   1529     bound = new_sig.bind(ax, *args, **kwargs)
   1530     auto_label = (bound.arguments.get(label_namer)
   1531                   or bound.kwargs.get(label_namer))

File ~/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/matplotlib/axes/_axes.py:7132, in Axes.hist(self, x, bins, range, density, weights, cumulative, bottom, histtype, align, orientation, rwidth, log, color, label, stacked, **kwargs)
   7128 # Loop through datasets
   7129 for i in range(nx):
   7130     # this will automatically overwrite bins,
   7131     # so that each histogram uses the same bins
-> 7132     m, bins = np.histogram(x[i], bins, weights=w[i], **hist_kwargs)
   7133     tops.append(m)
   7134 tops = np.array(tops, float)  # causes problems later if it's an int

File ~/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/numpy/lib/_histograms_impl.py:823, in histogram(a, bins, range, density, weights)
    821 # Pre-compute histogram scaling factor
    822 norm_numerator = n_equal_bins
--> 823 norm_denom = _unsigned_subtract(last_edge, first_edge)
    825 # We iterate over blocks here for two reasons: the first is that for
    826 # large arrays, it is actually faster (for example for a 10^8 array it
    827 # is 2x as fast) and it results in a memory footprint 3x lower in the
    828 # limit of large arrays.
    829 for i in _range(0, len(a), BLOCK):

File ~/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/numpy/lib/_histograms_impl.py:347, in _unsigned_subtract(a, b)
    345     unsigned_dt = signed_to_unsigned[dt.type]
    346 except KeyError:
--> 347     return np.subtract(a, b, dtype=dt)
    348 else:
    349     # we know the inputs are integers, and we are deliberately casting
    350     # signed to unsigned.  The input may be negative python integers so
    351     # ensure we pass in arrays with the initial dtype (related to NEP 50).
    352     return np.subtract(np.asarray(a, dtype=dt), np.asarray(b, dtype=dt),
    353                        casting='unsafe', dtype=unsigned_dt)

TypeError: numpy boolean subtract, the `-` operator, is not supported, use the bitwise_xor, the `^` operator, or the logical_xor function instead.

```

> SOLUTION:
>

Ah nice, we hit the ‚Äúnumpy boolean subtract‚Äù classic. This is happening because one of your **‚Äúnumeric‚Äù** columns is actually `bool`, and `np.histogram` + `matplotlib` is choking on it when you ask for 30 bins.

### What‚Äôs going wrong

In 2.10.3 you do:

```python
from pandas.api.types import is_numeric_dtype
...
numeric_cols_for_plots_2103 = [c for c in df_clean.columns if is_numeric_dtype(df_clean[c])]
...
ax.hist(s, bins=30, alpha=0.8)
```

`is_numeric_dtype(True/False)` returns `True`, so boolean columns are treated as numeric.
When `ax.hist` ‚Üí `np.histogram` tries to build 30-bin edges over a boolean dtype, you get:

> TypeError: numpy boolean subtract, the `-` operator, is not supported ‚Ä¶

So: **at least one of your columns is boolean**, and it‚Äôs being fed into the histogram.

You‚Äôve got two sensible options:

* Treat boolean columns as **categorical** (my preferred choice for a DQ engine).
* Or keep them numeric but coerce to `int` before plotting (0/1).

Below is a clean fix that treats booleans as **categorical** everywhere in 2.10A.

---

## Minimal patch: treat bool as categorical

### 1Ô∏è‚É£ Update numeric selection in 2.10.1 (summary)

Replace this part:

```python
if univ_num_enabled_2101:
    # Identify numeric columns (exclude IDs if schema hints exist)
    from pandas.api.types import is_numeric_dtype

    numeric_cols_2101 = []
    for col in df_clean.columns:
        if is_numeric_dtype(df_clean[col]):
            numeric_cols_2101.append(col)
```

with:

```python
if univ_num_enabled_2101:
    # Identify numeric columns (exclude IDs + booleans if schema hints exist)
    from pandas.api.types import is_numeric_dtype, is_bool_dtype

    numeric_cols_2101 = []
    for col in df_clean.columns:
        if is_numeric_dtype(df_clean[col]) and not is_bool_dtype(df_clean[col]):
            numeric_cols_2101.append(col)
```

So booleans are no longer in the numeric summary.

---

### 2Ô∏è‚É£ Update categorical selection in 2.10.2 (summary)

Replace this:

```python
if univ_cat_enabled_2102:
    from pandas.api.types import is_numeric_dtype

    categorical_cols_2102 = []
    for col in df_clean.columns:
        if not is_numeric_dtype(df_clean[col]):
            categorical_cols_2102.append(col)
```

with:

```python
if univ_cat_enabled_2102:
    from pandas.api.types import is_numeric_dtype, is_bool_dtype

    categorical_cols_2102 = []
    for col in df_clean.columns:
        # treat booleans as categorical
        if (not is_numeric_dtype(df_clean[col])) or is_bool_dtype(df_clean[col]):
            categorical_cols_2102.append(col)
```

Now booleans get swept into the categorical univariate summary, which is usually what you want for flags.

---

### 3Ô∏è‚É£ Update numeric / categorical lists in 2.10.3 (visuals)

Inside the `if univ_vis_enabled_2103:` block, change the ‚Äúfallback‚Äù branches.

**Numeric list fallback** ‚Äî replace:

```python
    else:
        from pandas.api.types import is_numeric_dtype

        numeric_cols_for_plots_2103 = [c for c in df_clean.columns if is_numeric_dtype(df_clean[c])]
```

with:

```python
    else:
        from pandas.api.types import is_numeric_dtype, is_bool_dtype

        numeric_cols_for_plots_2103 = [
            c for c in df_clean.columns
            if is_numeric_dtype(df_clean[c]) and not is_bool_dtype(df_clean[c])
        ]
```

**Categorical list fallback** ‚Äî replace:

```python
    else:
        from pandas.api.types import is_numeric_dtype

        categorical_cols_for_plots_2103 = [c for c in df_clean.columns if not is_numeric_dtype(df_clean[c])]
```

with:

```python
    else:
        from pandas.api.types import is_numeric_dtype, is_bool_dtype

        categorical_cols_for_plots_2103 = [
            c for c in df_clean.columns
            if (not is_numeric_dtype(df_clean[c])) or is_bool_dtype(df_clean[c])
        ]
```

After that, the plotting loops can stay exactly as-is; boolean columns won‚Äôt ever hit the histogram code, and they‚Äôll be drawn as bar plots instead (which is more meaningful for binary flags anyway).

---

## Optional alternative (if you *want* bools as numeric)

If you **do** want booleans in numeric plots, you can keep them in 2.10.1 and just coerce in the plotting loop:

```python
for col in numeric_cols_for_plots_2103:
    s = df_clean[col].dropna()
    if s.empty:
        continue

    if s.dtype == bool:
        s = s.astype(int)

    fig, ax = plt.subplots(figsize=(5, 3))
    ax.hist(s, bins=30, alpha=0.8)
    ...
```

But for a DQ / profiling engine, I‚Äôd stick with **‚Äúbool = categorical‚Äù** ‚Äî it makes your summaries and visuals much more interpretable.

If you paste those three patches in, the `numpy boolean subtract` error should disappear and 2.10A should run clean.





---
---

> Why would I want bools as numeric?

>Short answer: **you almost never *want* booleans treated as numeric in a data-quality engine.**
Here‚Äôs the clear breakdown:

---

# ‚úÖ Why booleans *usually should NOT* be numeric

### 1) **Binary variables aren‚Äôt continuous**

Numeric univariate summaries (mean, std, min/max, skew, kurtosis, histogram bins) are built for:
> **continuous distributions**

But a boolean column has only **two values: 0 and 1**.

So instead of getting something meaningful, you get:

* mean ‚Üí just the fraction of ‚ÄúTrue‚Äù
* std ‚Üí not meaningful for business interpretation
* histogram ‚Üí two spikes jammed into a 30-bin chart
* skew, kurtosis ‚Üí mathematically defined but *semantically useless*

A boolean‚Äôs distribution is categorical ‚Äî it has **two categories**.

---

# ‚úÖ Why booleans *should* be treated as categorical

A boolean is semantically:

* "Yes / No"
* "Active / Inactive"
* "Flag is set / not set"
* "Has this attribute / doesn't have it"

The information you want from a boolean is:

* What percent are True?
* What percent are False?
* Is the feature highly imbalanced (e.g., 99% False)?

Your categorical summary already handles this beautifully:

* category counts
* top share
* entropy
* dominance vs balanced

This is *exactly* the correct framing for booleans.

---

# ‚ùå Why booleans as numeric is problematic

### **(1) It breaks numeric plots**

This is the error you hit:

> numpy boolean subtract is not supported

Histograms assume a continuous numeric domain.
Booleans don‚Äôt have that.

### **(2) Your skew/kurt labels become nonsense**

A two-point distribution produces extreme skew/kurt values that don‚Äôt correspond to any real-world shape. They clutter DQ output.

### **(3) It pollutes numeric diagnostics**

Flags will look like:

* ‚Äúzero inflation‚Äù
* ‚Äúhigh skew‚Äù
* ‚Äúheavy tail‚Äù

‚Ä¶even though none of those concepts apply.

### **(4) It hides the real meaning**

If a column like `PaperlessBilling` is 75% True, you want to see:

```
Balanced (top_category_share=0.75)
```

Not:

```
Skewness=1.1 (High positive skew)
Kurtosis=0.1 (Light-tailed)
```

Those stats don't help anybody understand the variable.

---

# üéØ **When *might* you want booleans as numeric? (Rare)**

Almost never ‚Äî but here are the few exceptions:

### 1) **Feature engineering for ML (outside DQ)**

Some algorithms prefer a 0/1 version, but that‚Äôs *after* profiling ‚Äî not during.

### 2) **Correlation matrices**

If you treat bools as 0/1, you can compute:

* Pearson correlation with numeric features
* Point-biserial relationships

But again:
**For EDA ‚Üí treat as categorical.
For modeling ‚Üí cast to 0/1 later.**

### 3) **Proportion-level summaries**

Sometimes analysts like to see:

* The mean of a bool feature = % True

But you already get this from categorical value counts.

---

# üß† Final rule (DQ best practice)

### **Boolean = categorical feature**

Unless explicitly overridden.

This keeps your:

* summaries clean
* visuals meaningful
* diagnostics accurate
* pipeline robust

And it avoids exactly the kind of histogram crash you hit.

---

If you want, I can generate a **clean unified patch** that updates 2.10A everywhere so that booleans are treated correctly and consistently.
