
```py
# 2.10.6 | Categoricalâ€“Numeric Relationships
print("2.10.6 Categoricalâ€“numeric relationships")

default_bivar_cross_cfg = {
    "ENABLED": True,
    "TESTS": ["anova", "kruskal"],
    "MUTUAL_INFORMATION": True,
    "TARGETS": [],  # optional: for MI focus on specific targets (kept generic here)
    "OUTPUT_FILE": "bivariate_cross_association.csv",
}
bivar_cross_cfg = _get_cfg_210("BIVARIATE_CROSS", default_bivar_cross_cfg)

bivar_cross_enabled_2106 = bool(bivar_cross_cfg.get("ENABLED", True))
bivar_cross_tests_2106 = list(bivar_cross_cfg.get("TESTS", ["anova", "kruskal"]))
bivar_cross_use_mi_2106 = bool(bivar_cross_cfg.get("MUTUAL_INFORMATION", True))
bivar_cross_targets_2106 = list(bivar_cross_cfg.get("TARGETS", []))
bivar_cross_output_file_2106 = str(
    bivar_cross_cfg.get("OUTPUT_FILE", "bivariate_cross_association.csv")
)

bivar_cross_matrix_path_2106 = section2_reports_dir_210 / bivar_cross_output_file_2106

bivar_cross_df_2106 = pd.DataFrame()
n_pairs_2106 = 0
n_significant_2106 = 0

# Try to import SciPy for real p-values; fall back to approximate F-like statistic otherwise
try:
    from scipy.stats import f_oneway as _f_oneway_2106, kruskal as _kruskal_2106
    _HAS_SCIPY_2106 = True
except Exception:
    _HAS_SCIPY_2106 = False


def _qcut_codes_2106(s: pd.Series, q: int = 5) -> pd.Series:
    """Return quantile-binned labels as strings (for MI)."""
    try:
        bins = pd.qcut(s, q=q, duplicates="drop")
        return bins.astype("str")
    except Exception:
        # fall back to all-NaN series on failure
        return pd.Series(index=s.index, data=np.nan)


def _entropy_generic_2106(s: pd.Series) -> float:
    """Shannon entropy H(s) in bits for a discrete series."""
    # value_counts(normalize=True) gives probabilities directly
    vc = s.value_counts(normalize=True, dropna=True)
    if vc.empty:
        return np.nan
    p = vc.values.astype(float)
    with np.errstate(divide="ignore", invalid="ignore"):
        return float(-(p * np.log2(p + 1e-15)).sum())


def _joint_entropy_2106(x: pd.Series, y: pd.Series) -> float:
    """Joint entropy H(X,Y) in bits."""
    df_xy = pd.DataFrame({"x": x, "y": y}).dropna()
    if df_xy.empty:
        return np.nan
    vc = df_xy.value_counts(normalize=True)
    if vc.empty:
        return np.nan
    p = vc.values.astype(float)
    with np.errstate(divide="ignore", invalid="ignore"):
        return float(-(p * np.log2(p + 1e-15)).sum())


def _mutual_information_2106(x: pd.Series, y: pd.Series) -> float:
    """Mutual information I(X;Y) in bits for discrete/categorical X,Y."""
    df_xy = pd.DataFrame({"x": x, "y": y}).dropna()
    if df_xy.empty:
        return np.nan
    h_x = _entropy_generic_2106(df_xy["x"])
    h_y = _entropy_generic_2106(df_xy["y"])
    h_xy = _joint_entropy_2106(df_xy["x"], df_xy["y"])
    if any(np.isnan(v) for v in (h_x, h_y, h_xy)):
        return np.nan
    mi = h_x + h_y - h_xy
    # Numerical noise can make MI slightly negative; clamp to 0
    return float(max(0.0, mi))


if bivar_cross_enabled_2106:
    # Numeric features (reuse 2.10.1 if available)
    if (
        "num_summary_df_2101" in globals()
        and isinstance(num_summary_df_2101, pd.DataFrame)
        and not num_summary_df_2101.empty
    ):
        numeric_cols_2106 = [
            c for c in num_summary_df_2101["feature"] if c in df_clean.columns
        ]
    else:
        from pandas.api.types import is_numeric_dtype, is_bool_dtype

        numeric_cols_2106 = [
            c
            for c in df_clean.columns
            if is_numeric_dtype(df_clean[c]) and not is_bool_dtype(df_clean[c])
        ]

    # Categorical features (reuse 2.10.2 if available)
    if (
        "cat_summary_df_2102" in globals()
        and isinstance(cat_summary_df_2102, pd.DataFrame)
        and not cat_summary_df_2102.empty
    ):
        categorical_cols_2106 = [
            c for c in cat_summary_df_2102["feature"] if c in df_clean.columns
        ]
    else:
        from pandas.api.types import is_numeric_dtype, is_bool_dtype

        categorical_cols_2106 = [
            c
            for c in df_clean.columns
            if (not is_numeric_dtype(df_clean[c])) or is_bool_dtype(df_clean[c])
        ]

    rows_2106 = []
    for cat_col in categorical_cols_2106:
        for num_col in numeric_cols_2106:
            s_cat = df_clean[cat_col]
            s_num = df_clean[num_col]
            valid = s_cat.notna() & s_num.notna()
            if valid.sum() < 3:
                continue

            s_cat_valid = s_cat[valid].astype("object")
            s_num_valid = s_num[valid].astype(float)

            # group arrays for tests
            groups = [
                s_num_valid[s_cat_valid == level].values
                for level in s_cat_valid.unique()
            ]
            groups = [g for g in groups if g.size > 0]

            test_method_used = None
            test_stat = np.nan
            p_value = np.nan

            if "anova" in bivar_cross_tests_2106 and len(groups) >= 2:
                test_method_used = "anova"
                if _HAS_SCIPY_2106:
                    try:
                        stat, p = _f_oneway_2106(*groups)
                        test_stat = float(stat)
                        p_value = float(p)
                    except Exception:
                        test_stat = np.nan
                        p_value = np.nan
                else:
                    # simple F-like ratio as placeholder when SciPy missing
                    grand_mean = s_num_valid.mean()
                    ss_between = sum(
                        g.size * (g.mean() - grand_mean) ** 2 for g in groups
                    )
                    ss_within = sum(((g - g.mean()) ** 2).sum() for g in groups)
                    df_between = len(groups) - 1
                    df_within = max(1, valid.sum() - len(groups))
                    ms_between = ss_between / df_between if df_between > 0 else np.nan
                    ms_within = ss_within / df_within if df_within > 0 else np.nan
                    test_stat = (
                        (ms_between / ms_within)
                        if (ms_between > 0 and ms_within > 0)
                        else np.nan
                    )
                    p_value = np.nan  # cannot compute exact p without SciPy

            elif "kruskal" in bivar_cross_tests_2106 and len(groups) >= 2:
                test_method_used = "kruskal"
                if _HAS_SCIPY_2106:
                    try:
                        stat, p = _kruskal_2106(*groups)
                        test_stat = float(stat)
                        p_value = float(p)
                    except Exception:
                        test_stat = np.nan
                        p_value = np.nan
                else:
                    test_stat = np.nan
                    p_value = np.nan

            # Mutual information: between categorical and binned numeric
            mi_val = np.nan
            if bivar_cross_use_mi_2106:
                binned_num = _qcut_codes_2106(s_num_valid, q=5)
                mi_val = _mutual_information_2106(s_cat_valid, binned_num)

            # Effect label
            if not np.isnan(p_value):
                if p_value < 0.01:
                    effect_label = "Strong"
                elif p_value < 0.05:
                    effect_label = "Moderate"
                elif p_value < 0.1:
                    effect_label = "Weak"
                else:
                    effect_label = "Not significant"
            else:
                if not np.isnan(mi_val) and mi_val >= 0.5:
                    effect_label = "Strong (MI)"
                elif not np.isnan(mi_val) and mi_val >= 0.2:
                    effect_label = "Moderate (MI)"
                elif not np.isnan(mi_val) and mi_val > 0:
                    effect_label = "Weak (MI)"
                else:
                    effect_label = "Unknown"

            rows_2106.append(
                {
                    "categorical_feature": cat_col,
                    "numeric_feature": num_col,
                    "test_method": test_method_used,
                    "test_statistic": test_stat,
                    "p_value": p_value,
                    "mutual_information": mi_val,
                    "effect_label": effect_label,
                }
            )

    bivar_cross_df_2106 = pd.DataFrame(rows_2106)
    n_pairs_2106 = int(bivar_cross_df_2106.shape[0])
    n_significant_2106 = int(
        (
            bivar_cross_df_2106["p_value"].notna()
            & (bivar_cross_df_2106["p_value"] < 0.05)
        ).sum()
    )

    tmp_path_2106 = bivar_cross_matrix_path_2106.with_suffix(".tmp.csv")
    bivar_cross_df_2106.to_csv(tmp_path_2106, index=False)
    os.replace(tmp_path_2106, bivar_cross_matrix_path_2106)

if n_pairs_2106 == 0:
    status_2106 = "WARN"
else:
    frac_sig_2106 = n_significant_2106 / max(1, n_pairs_2106)
    if frac_sig_2106 <= 0.3:
        status_2106 = "OK"
    elif frac_sig_2106 <= 0.7:
        status_2106 = "WARN"
    else:
        status_2106 = "FAIL"

sig_rate_2106 = (
    float(n_significant_2106) / n_pairs_2106
    if n_pairs_2106 and n_pairs_2106 > 0
    else None
)

summary_2106 = pd.DataFrame([{
    "section": "2.10.6",
    "section_name": "Categoricalâ€“numeric relationships",
    "check": "Run group difference tests and mutual information for catâ€“num pairs",
    "level": "info",
    "status": status_2106,
    "n_pairs": int(n_pairs_2106),
    "n_significant": int(n_significant_2106),
    "significance_rate": sig_rate_2106,
    "detail": str(bivar_cross_matrix_path_2106),
    "timestamp": pd.Timestamp.utcnow(),
}])

append_sec2(summary_2106, SECTION2_REPORT_PATH)

display(summary_2106)
2.10.6 Categoricalâ€“numeric relationships
/Users/b/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/scipy/stats/_axis_nan_policy.py:579: ConstantInputWarning: Each of the input arrays is constant; the F statistic is not defined or infinite
  res = hypotest_fun_out(*samples, **kwds)
/Users/b/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/scipy/stats/_axis_nan_policy.py:579: ConstantInputWarning: Each of the input arrays is constant; the F statistic is not defined or infinite
  res = hypotest_fun_out(*samples, **kwds)
/Users/b/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/scipy/stats/_axis_nan_policy.py:579: ConstantInputWarning: Each of the input arrays is constant; the F statistic is not defined or infinite
  res = hypotest_fun_out(*samples, **kwds)
/Users/b/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/scipy/stats/_axis_nan_policy.py:579: ConstantInputWarning: Each of the input arrays is constant; the F statistic is not defined or infinite
  res = hypotest_fun_out(*samples, **kwds)
/Users/b/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/scipy/stats/_axis_nan_policy.py:579: ConstantInputWarning: Each of the input arrays is constant; the F statistic is not defined or infinite
  res = hypotest_fun_out(*samples, **kwds)
/Users/b/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/scipy/stats/_axis_nan_policy.py:579: ConstantInputWarning: Each of the input arrays is constant; the F statistic is not defined or infinite
  res = hypotest_fun_out(*samples, **kwds)
/Users/b/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/scipy/stats/_axis_nan_policy.py:579: ConstantInputWarning: Each of the input arrays is constant; the F statistic is not defined or infinite
  res = hypotest_fun_out(*samples, **kwds)
/Users/b/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/scipy/stats/_axis_nan_policy.py:579: ConstantInputWarning: Each of the input arrays is constant; the F statistic is not defined or infinite
  res = hypotest_fun_out(*samples, **kwds)
/Users/b/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/scipy/stats/_axis_nan_policy.py:579: ConstantInputWarning: Each of the input arrays is constant; the F statistic is not defined or infinite
  res = hypotest_fun_out(*samples, **kwds)
/Users/b/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/scipy/stats/_axis_nan_policy.py:579: ConstantInputWarning: Each of the input arrays is constant; the F statistic is not defined or infinite
  res = hypotest_fun_out(*samples, **kwds)
/Users/b/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/scipy/stats/_axis_nan_policy.py:579: ConstantInputWarning: Each of the input arrays is constant; the F statistic is not defined or infinite
  res = hypotest_fun_out(*samples, **kwds)
/Users/b/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/scipy/stats/_axis_nan_policy.py:579: ConstantInputWarning: Each of the input arrays is constant; the F statistic is not defined or infinite
  res = hypotest_fun_out(*samples, **kwds)
/Users/b/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/scipy/stats/_axis_nan_policy.py:579: ConstantInputWarning: Each of the input arrays is constant; the F statistic is not defined or infinite
  res = hypotest_fun_out(*samples, **kwds)
/Users/b/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/scipy/stats/_axis_nan_policy.py:579: ConstantInputWarning: Each of the input arrays is constant; the F statistic is not defined or infinite
  res = hypotest_fun_out(*samples, **kwds)
/Users/b/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/scipy/stats/_axis_nan_policy.py:579: ConstantInputWarning: Each of the input arrays is constant; the F statistic is not defined or infinite
  res = hypotest_fun_out(*samples, **kwds)
/Users/b/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/scipy/stats/_axis_nan_policy.py:579: ConstantInputWarning: Each of the input arrays is constant; the F statistic is not defined or infinite
  res = hypotest_fun_out(*samples, **kwds)
/Users/b/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/scipy/stats/_axis_nan_policy.py:579: ConstantInputWarning: Each of the input arrays is constant; the F statistic is not defined or infinite
  res = hypotest_fun_out(*samples, **kwds)
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_91085/908984331.py:48: FutureWarning: The behavior of value_counts with object-dtype is deprecated. In a future version, this will *not* perform dtype inference on the resulting index. To retain the old behavior, use `result.index = result.index.infer_objects()`
  vc = s.value_counts(normalize=True, dropna=True)
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_91085/908984331.py:48: FutureWarning: The behavior of value_counts with object-dtype is deprecated. In a future version, this will *not* perform dtype inference on the resulting index. To retain the old behavior, use `result.index = result.index.infer_objects()`
  vc = s.value_counts(normalize=True, dropna=True)
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_91085/908984331.py:48: FutureWarning: The behavior of value_counts with object-dtype is deprecated. In a future version, this will *not* perform dtype inference on the resulting index. To retain the old behavior, use `result.index = result.index.infer_objects()`
  vc = s.value_counts(normalize=True, dropna=True)
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_91085/908984331.py:48: FutureWarning: The behavior of value_counts with object-dtype is deprecated. In a future version, this will *not* perform dtype inference on the resulting index. To retain the old behavior, use `result.index = result.index.infer_objects()`
  vc = s.value_counts(normalize=True, dropna=True)
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_91085/908984331.py:48: FutureWarning: The behavior of value_counts with object-dtype is deprecated. In a future version, this will *not* perform dtype inference on the resulting index. To retain the old behavior, use `result.index = result.index.infer_objects()`
  vc = s.value_counts(normalize=True, dropna=True)
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_91085/908984331.py:48: FutureWarning: The behavior of value_counts with object-dtype is deprecated. In a future version, this will *not* perform dtype inference on the resulting index. To retain the old behavior, use `result.index = result.index.infer_objects()`
  vc = s.value_counts(normalize=True, dropna=True)
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_91085/908984331.py:48: FutureWarning: The behavior of value_counts with object-dtype is deprecated. In a future version, this will *not* perform dtype inference on the resulting index. To retain the old behavior, use `result.index = result.index.infer_objects()`
  vc = s.value_counts(normalize=True, dropna=True)
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_91085/908984331.py:48: FutureWarning: The behavior of value_counts with object-dtype is deprecated. In a future version, this will *not* perform dtype inference on the resulting index. To retain the old behavior, use `result.index = result.index.infer_objects()`
  vc = s.value_counts(normalize=True, dropna=True)
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_91085/908984331.py:48: FutureWarning: The behavior of value_counts with object-dtype is deprecated. In a future version, this will *not* perform dtype inference on the resulting index. To retain the old behavior, use `result.index = result.index.infer_objects()`
  vc = s.value_counts(normalize=True, dropna=True)
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_91085/908984331.py:48: FutureWarning: The behavior of value_counts with object-dtype is deprecated. In a future version, this will *not* perform dtype inference on the resulting index. To retain the old behavior, use `result.index = result.index.infer_objects()`
  vc = s.value_counts(normalize=True, dropna=True)
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_91085/908984331.py:48: FutureWarning: The behavior of value_counts with object-dtype is deprecated. In a future version, this will *not* perform dtype inference on the resulting index. To retain the old behavior, use `result.index = result.index.infer_objects()`
  vc = s.value_counts(normalize=True, dropna=True)
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_91085/908984331.py:48: FutureWarning: The behavior of value_counts with object-dtype is deprecated. In a future version, this will *not* perform dtype inference on the resulting index. To retain the old behavior, use `result.index = result.index.infer_objects()`
  vc = s.value_counts(normalize=True, dropna=True)
/Users/b/DATA/PROJECTS/Telco/.venv/lib/python3.12/site-packages/scipy/stats/_axis_nan_policy.py:579: ConstantInputWarning: Each of the input arrays is constant; the F statistic is not defined or infinite
  res = hypotest_fun_out(*samples, **kwds)
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_91085/908984331.py:48: FutureWarning: The behavior of value_counts with object-dtype is deprecated. In a future version, this will *not* perform dtype inference on the resulting index. To retain the old behavior, use `result.index = result.index.infer_objects()`
  vc = s.value_counts(normalize=True, dropna=True)
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_91085/908984331.py:48: FutureWarning: The behavior of value_counts with object-dtype is deprecated. In a future version, this will *not* perform dtype inference on the resulting index. To retain the old behavior, use `result.index = result.index.infer_objects()`
  vc = s.value_counts(normalize=True, dropna=True)
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_91085/908984331.py:48: FutureWarning: The behavior of value_counts with object-dtype is deprecated. In a future version, this will *not* perform dtype inference on the resulting index. To retain the old behavior, use `result.index = result.index.infer_objects()`
  vc = s.value_counts(normalize=True, dropna=True)
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_91085/908984331.py:48: FutureWarning: The behavior of value_counts with object-dtype is deprecated. In a future version, this will *not* perform dtype inference on the resulting index. To retain the old behavior, use `result.index = result.index.infer_objects()`
  vc = s.value_counts(normalize=True, dropna=True)
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_91085/908984331.py:48: FutureWarning: The behavior of value_counts with object-dtype is deprecated. In a future version, this will *not* perform dtype inference on the resulting index. To retain the old behavior, use `result.index = result.index.infer_objects()`
  vc = s.value_counts(normalize=True, dropna=True)
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_91085/908984331.py:48: FutureWarning: The behavior of value_counts with object-dtype is deprecated. In a future version, this will *not* perform dtype inference on the resulting index. To retain the old behavior, use `result.index = result.index.infer_objects()`
  vc = s.value_counts(normalize=True, dropna=True)
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_91085/908984331.py:48: FutureWarning: The behavior of value_counts with object-dtype is deprecated. In a future version, this will *not* perform dtype inference on the resulting index. To retain the old behavior, use `result.index = result.index.infer_objects()`
  vc = s.value_counts(normalize=True, dropna=True)
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_91085/908984331.py:48: FutureWarning: The behavior of value_counts with object-dtype is deprecated. In a future version, this will *not* perform dtype inference on the resulting index. To retain the old behavior, use `result.index = result.index.infer_objects()`
  vc = s.value_counts(normalize=True, dropna=True)
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_91085/908984331.py:48: FutureWarning: The behavior of value_counts with object-dtype is deprecated. In a future version, this will *not* perform dtype inference on the resulting index. To retain the old behavior, use `result.index = result.index.infer_objects()`
  vc = s.value_counts(normalize=True, dropna=True)
/var/folders/dn/wtcqyjbd1hn63s40771sdddm0000gn/T/ipykernel_91085/908984331.py:48: FutureWarning: The behavior of value_counts with object-dtype is deprecated. In a future version, this will *not* perform dtype inference on the resulting index. To retain the old behavior, use `result.index = result.index.infer_objects()`
  vc = s.value_counts(normalize=True, dropna=True)
ðŸ§¾ Appended diagnostics â†’ /Users/b/DATA/PROJECTS/Telco/Level_3/resources/reports/section2/section2_data_quality_20251212_125302.csv
```

># Solution:

Nice, it ran and appended to Section 2 ðŸŽ‰ Now youâ€™re just seeing two kinds of *annoying but harmless* noise:

1. **`ConstantInputWarning` from SciPy (ANOVA)**
2. **`FutureWarning` from `value_counts` in `_entropy_generic_2106`**

Letâ€™s clean both without changing the logic.

---

## 1. SciPy `ConstantInputWarning`

> `ConstantInputWarning: Each of the input arrays is constant; the F statistic is not defined or infinite`

This happens when, for a given categoricalâ€“numeric pair, **every group has zero variance** (e.g., all the same value). ANOVA literally canâ€™t compute an F-statistic because thereâ€™s nothing to compare.

Statistically, those pairs are â€œno signal hereâ€. You can safely:

* Treat the test as `NaN` and
* Let MI handle any rare structured signal (usually there wonâ€™t be any either).

ðŸ’¡ðŸ’¡ **Patch: skip ANOVA when all groups are constant**

Add this helper near your other defs:

```python
def _all_groups_constant_2106(groups) -> bool:
    """Return True if every group has zero variance (all values identical)."""
    for g in groups:
        if g.size == 0:
            continue
        if not np.allclose(g, g[0]):
            return False
    return True
```

Then update the ANOVA block like this:

```python
if "anova" in bivar_cross_tests_2106 and len(groups) >= 2:
    test_method_used = "anova"

    # Skip ANOVA when all groups are constant to avoid ConstantInputWarning
    if _all_groups_constant_2106(groups):
        test_stat = np.nan
        p_value = np.nan
    elif _HAS_SCIPY_2106:
        try:
            stat, p = _f_oneway_2106(*groups)
            test_stat = float(stat)
            p_value = float(p)
        except Exception:
            test_stat = np.nan
            p_value = np.nan
    else:
        # simple F-like ratio as placeholder when SciPy missing
        grand_mean = s_num_valid.mean()
        ss_between = sum(
            g.size * (g.mean() - grand_mean) ** 2 for g in groups
        )
        ss_within = sum(((g - g.mean()) ** 2).sum() for g in groups)
        df_between = len(groups) - 1
        df_within = max(1, valid.sum() - len(groups))
        ms_between = ss_between / df_between if df_between > 0 else np.nan
        ms_within = ss_within / df_within if df_within > 0 else np.nan
        test_stat = (
            (ms_between / ms_within)
            if (ms_between > 0 and ms_within > 0)
            else np.nan
        )
        p_value = np.nan  # cannot compute exact p without SciPy
```

Now SciPy never even gets called in the â€œall groups constantâ€ case, so the warnings disappear and the semantics are correct: **no variance â†’ no test**.

---

## 2. `FutureWarning` from `_entropy_generic_2106`

> `The behavior of value_counts with object-dtype is deprecated... To retain the old behavior, use result.index = result.index.infer_objects()`

Pandas is just telling you: â€œHey, in the future, I wonâ€™t auto-infer dtypes from the index of `value_counts` for object dtypes.â€ We donâ€™t actually *care* about the index type for entropy, but we can follow their advice and silence it.

ðŸ’¡ðŸ’¡ **Patch: explicitly infer index objects**

Replace `_entropy_generic_2106` with:

```python
def _entropy_generic_2106(s: pd.Series) -> float:
    """Shannon entropy H(s) in bits for a discrete series."""
    vc = s.value_counts(normalize=True, dropna=True)

    # Future-proof: ensure index dtype inference happens explicitly
    if hasattr(vc.index, "infer_objects"):
        vc.index = vc.index.infer_objects()

    if vc.empty:
        return np.nan
    p = vc.values.astype(float)
    with np.errstate(divide="ignore", invalid="ignore"):
        return float(-(p * np.log2(p + 1e-15)).sum())
```

That should silence the `FutureWarning` spam while keeping the calculation identical.

---

## Sanity check / interpretation

* The **Section 2 summary row** is appended and looks good.
* For any pairs where:

  * ANOVA/Kruskal canâ€™t run (constant groups) â†’ `p_value = NaN`, effect label will fall back to MI-based labels.
  * MI is small/zero â†’ those pairs are basically â€œno relationshipâ€.

You now have a pretty robust **catâ€“num association grid** with:

* proper drift/relationship signal,
* quiet logs,
* and clean stats for downstream dashboards. âœ…


---
---
># ?
># How to fix the FutureWRNING:

Yeah, this oneâ€™s extra annoying because the warning text mentions `result` but your code is using `vc`, so itâ€™s not obvious what it wants ðŸ™ƒ

Pandas is basically saying:

> â€œWhen you call `value_counts` on an `object`-dtype Series, **donâ€™t rely on me auto-inferring types on the index in the future**. If you care about that, do the inference yourself.â€

Right now you have:

```python
vc = s.value_counts(normalize=True, dropna=True)

if hasattr(vc.index, "infer_objects"):
    vc.index = vc.index.infer_objects()
```

Conceptually thatâ€™s right, but the warning is still firing because itâ€™s triggered at the `value_counts` call itself. The official suggestion is literally:

```python
result = value_counts(...)
result.index = result.index.infer_objects()
```

Letâ€™s follow that pattern exactly, *and* do the same for the joint entropy.

### 1. Update `_entropy_generic_2106`

Replace it with:

```python
def _entropy_generic_2106(s: pd.Series) -> float:
    """Shannon entropy H(s) in bits for a discrete series."""
    # Explicitly follow pandas' suggested pattern
    result = s.value_counts(normalize=True, dropna=True)

    # Future-proof: ensure index dtype inference happens explicitly
    if hasattr(result.index, "infer_objects"):
        result.index = result.index.infer_objects()

    if result.empty:
        return np.nan

    p = result.values.astype(float)
    with np.errstate(divide="ignore", invalid="ignore"):
        return float(-(p * np.log2(p + 1e-15)).sum())
```

### 2. Update `_joint_entropy_2106`

Do the same with the `value_counts` there:

```python
def _joint_entropy_2106(x: pd.Series, y: pd.Series) -> float:
    """Joint entropy H(X,Y) in bits."""
    df_xy = pd.DataFrame({"x": x, "y": y}).dropna()
    if df_xy.empty:
        return np.nan

    result = df_xy.value_counts(normalize=True)

    if hasattr(result.index, "infer_objects"):
        result.index = result.index.infer_objects()

    if result.empty:
        return np.nan

    p = result.values.astype(float)
    with np.errstate(divide="ignore", invalid="ignore"):
        return float(-(p * np.log2(p + 1e-15)).sum())
```

### 3. Make sure the *new* functions are in effect

Because Jupyter sometimes keeps the old version if cells are run out of order:

1. Run the cell that defines these functions.
2. Then re-run the 2.10.6 cell.
3. If the warning persists, restart kernel â†’ run your Section 2 bootstrap â†’ rerun 2.10.6.

---

ðŸ’¡ðŸ’¡ **Alternative (if you just want silence):**

If you donâ€™t care about the exact index dtype, you can also avoid object-dtype `value_counts` entirely:

```python
result = s.astype("string").value_counts(normalize=True, dropna=True)
```

That bypasses the deprecation path altogether.

Either way, your stats are already fine; this is just about shutting up the FutureWarning so your logs are clean.
