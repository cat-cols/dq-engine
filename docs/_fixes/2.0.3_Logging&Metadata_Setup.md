># Why is it not finding the dataset version registry

```python
# NEW 2.0.3 üßæ Logging & Metadata Setup
print("üìã 2.0.3 üßæ Logging & Metadata Setup")

# 0) Canonical run timestamp

# Ensure RUN_TS exists (single run identifier used everywhere)
if "RUN_TS" not in globals():
    # üí°üí° Prefer UTC for a global-safe run key; keep filename-safe format
    RUN_TS = datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")

# 1) Timestamp (UTC ISO 8601)
ts_s2_run_start_utc = datetime.now(timezone.utc).isoformat(timespec="seconds").replace("+00:00", "Z")

# 2) Git hash (optional)
git_hash = None
try:
    if "PROJECT_ROOT" in globals() and PROJECT_ROOT:
        git_hash = (
            subprocess.check_output(["git", "rev-parse", "HEAD"], cwd=PROJECT_ROOT)
            .decode("utf-8")
            .strip()
        )
except Exception:
    print("‚ö†Ô∏è  Git hash unavailable (not a repo or no git installed).")

short_git = (git_hash or "nogit")[:7]

# 3) Script / notebook name
script_name = "unknown_environment"
try:
    script_name = Path(__file__).name
except Exception:
    try:
        import sys
        if getattr(sys, "argv", None) and sys.argv and str(sys.argv[0]).endswith(".ipynb"):
            script_name = Path(sys.argv[0]).name
        else:
            script_name = "interactive_notebook"
    except Exception:
        script_name = "unknown_environment"

# 4) Dataset version lookup
version_id = None
REGISTRY_DIR = globals().get("REGISTRY_DIR", (ARTIFACTS_DIR / "registry").resolve())
REGISTRY_DIR.mkdir(parents=True, exist_ok=True)
version_registry_path = REGISTRY_DIR / "dataset_version_registry.csv"

if version_registry_path.exists():
    try:
        reg_df = pd.read_csv(version_registry_path)
        if not reg_df.empty and "version_id" in reg_df.columns:
            version_id = str(reg_df["version_id"].iloc[-1])
    except Exception as e:
        print(f"‚ö†Ô∏è Could not read dataset version registry: {e}")
else:
    print(f"‚ö†Ô∏è Dataset version registry not found: {version_registry_path}")


# 5) RUN_ID (correlates across logs + branches)
RUN_ID = f"{RUN_TS}_{short_git}"

# 6) Compose metadata record
SEC2_REPORTS_DIR = globals().get("SEC2_REPORTS_DIR")  # normalize once

section2_run_metadata = {
    # Join keys (use these everywhere)
    "run_ts": RUN_TS,                 # filename-safe, canonical run key
    "run_id": RUN_ID,                 # best for correlation in logs/registries

    # Time anchors
    "timestamp_utc": ts_s2_run_start_utc,

    # Provenance
    "git_hash": git_hash,
    "script_or_notebook": script_name,
    "dataset_version_id": version_id,

    # Paths / context
    "project_root": str(PROJECT_ROOT) if "PROJECT_ROOT" in globals() else None,
    "level_name": str(LEVEL_NAME) if "LEVEL_NAME" in globals() else None,
    "level_root": str(LEVEL_ROOT) if "LEVEL_ROOT" in globals() else None,
    "reports_dir": str(REPORTS_DIR) if "REPORTS_DIR" in globals() else None,
    "section2_reports_dir": str(SEC2_REPORTS_DIR) if SEC2_REPORTS_DIR else None,
    "section2_report_path": str(globals().get("SECTION2_REPORT_PATH")) if globals().get("SECTION2_REPORT_PATH") else None,

    # Operator / environment
    "user": os.getenv("USER") or os.getenv("USERNAME") or "unknown",
    "hostname": platform.node(),
    "python_version": sys.version.split()[0],
    "platform": platform.platform(),
    "pid": os.getpid(),

    # Config/data pointers
    "config_path": str(CONFIG_PATH) if "CONFIG_PATH" in globals() else None,
    "raw_data": str(RAW_DATA) if "RAW_DATA" in globals() else None,
}

# 7) Save metadata snapshot (atomic write)
metadata_path = (ARTIFACTS_DIR / f"section2_run_metadata_{RUN_TS}.json").resolve()
tmp_path = metadata_path.with_suffix(".tmp")

tmp_path.parent.mkdir(parents=True, exist_ok=True)
with open(tmp_path, "w", encoding="utf-8") as f:
    json.dump(section2_run_metadata, f, indent=2)
os.replace(tmp_path, metadata_path)

# Optional: stable "latest" pointer
latest_path = (ARTIFACTS_DIR / "section2_run_metadata_latest.json").resolve()
tmp_latest = latest_path.with_suffix(".tmp")
with open(tmp_latest, "w", encoding="utf-8") as f:
    json.dump(section2_run_metadata, f, indent=2)
os.replace(tmp_latest, latest_path)

print(f"‚úÖ Section 2 run metadata written ‚Üí {metadata_path}")
print(json.dumps(section2_run_metadata, indent=2))

# 8) Append to unified Section 2 report
meta_chunk = pd.DataFrame([{
    "section":      "2.0.3",
    "section_name": "Logging & metadata setup",
    "check":        "Section 2 run metadata snapshot",
    "level":        "info",
    "status":       "OK",
    "detail":       f"Metadata saved to {metadata_path.name}",
    "timestamp":    pd.Timestamp.utcnow(),   # üí°üí° keep UTC here too
    # critical join keys:
    "run_ts":       RUN_TS,
    "run_id":       RUN_ID,
    # useful context:
    "dataset_version_id": section2_run_metadata.get("dataset_version_id"),
    "git_hash":           section2_run_metadata.get("git_hash"),
}])

display(meta_chunk)

append_sec2(meta_chunk, SECTION2_REPORT_PATH)
SECTION2_APPEND_SECTIONS.add("2.0.3")

# 9) Debugging toggle
DEBUG_SECTION2 = False
if DEBUG_SECTION2:
    print(SECTION2_REPORT_PATH)
    print(SECTION2_REPORT_PATH.exists())
    display(pd.read_csv(SECTION2_REPORT_PATH).tail())

output:
üìã 2.0.3 üßæ Logging & Metadata Setup
‚ö†Ô∏è Dataset version registry not found: /Users/b/DATA/PROJECTS/Telco/_T2/Level_3/resources/artifacts/section2/registry/dataset_version_registry.csv
‚úÖ Section 2 run metadata written ‚Üí /Users/b/DATA/PROJECTS/Telco/_T2/Level_3/resources/artifacts/section2_run_metadata_20251219_193156.json
{
  "run_ts": "20251219_193156",
  "run_id": "20251219_193156_8a8d58a",
  "timestamp_utc": "2025-12-21T22:30:16Z",
  "git_hash": "8a8d58a13991f5a8d82f02c37d12ce6b98d1cea3",
  "script_or_notebook": "interactive_notebook",
  "dataset_version_id": null,
  "project_root": "/Users/b/DATA/PROJECTS/Telco",
  "level_name": "Level_3",
  "level_root": "/Users/b/DATA/PROJECTS/Telco/_T2/Level_3",
  "reports_dir": "/Users/b/DATA/PROJECTS/Telco/_T2/Level_3/resources/reports",
  "section2_reports_dir": "/Users/b/DATA/PROJECTS/Telco/_T2/Level_3/resources/reports/section2",
  "section2_report_path": "/Users/b/DATA/PROJECTS/Telco/_T2/Level_3/resources/reports/section2/section2_data_quality_20251219_193156.csv",
  "user": "b",
  "hostname": "Brandons-iMac.local",
  "python_version": "3.12.6",
  "platform": "macOS-12.7.6-x86_64-i386-64bit",
  "pid": 65339,
  "config_path": "/Users/b/DATA/PROJECTS/Telco/_T2/Level_3/config/project_config.yaml",
  "raw_data": "/Users/b/DATA/PROJECTS/Telco/data/_raw/WA_Fn-UseC_-Telco-Customer-Churn.csv"
}
```

---
---

>## Fix

Is this *suggested* fix true?

```python
REGISTRY_DIR = globals().get("REGISTRY_DIR", (ARTIFACTS_DIR / "registry").resolve())
REGISTRY_DIR.mkdir(parents=True, exist_ok=True)
version_registry_path = REGISTRY_DIR / "dataset_version_registry.csv"
```

It‚Äôs not finding it because **your code is looking in a different directory than where (you likely) created it**.

### What your code is doing

You set:

```python
REGISTRY_DIR = (ARTIFACTS_DIR / "registry").resolve()
```

But in your run, `ARTIFACTS_DIR` is **level artifacts**:

```
/Users/b/.../Level_3/resources/artifacts
```

So it looks for:

```
/Users/b/.../Level_3/resources/artifacts/registry/dataset_version_registry.csv
```

Yet your warning shows it‚Äôs actually looking for:

```
/Users/b/.../Level_3/resources/artifacts/section2/registry/dataset_version_registry.csv
```

That tells me **REGISTRY_DIR is currently set elsewhere in your notebook** (probably earlier bootstrap code) to:

```
REGISTRY_DIR = SEC2_ARTIFACTS_DIR / "registry"
```

and `SEC2_ARTIFACTS_DIR` is:

```
/Users/b/.../Level_3/resources/artifacts/section2
```

So your code is expecting the version registry inside the **Section 2 artifacts tree**.

### The most common cause

You probably created `dataset_version_registry.csv` under **Section 1‚Äôs registry** (or under level artifacts), something like:

* `/resources/artifacts/registry/dataset_version_registry.csv` (level-wide), or
* `/resources/artifacts/section1/registry/dataset_version_registry.csv` (section1-wide)

‚Ä¶but in 2.0.3 you‚Äôre looking under:

* `/resources/artifacts/section2/registry/dataset_version_registry.csv`

### What to do (pick ONE convention)

You have two sane options.

#### Option A (recommended): make dataset version registry **level-wide**

Dataset version is not ‚ÄúSection 2 specific‚Äù ‚Äî it‚Äôs the dataset. Put it here:

```
ARTIFACTS_DIR / "registry" / "dataset_version_registry.csv"
```

Then in 2.0.3, force:

```python
REGISTRY_DIR = (ARTIFACTS_DIR / "registry").resolve()
```

‚Ä¶and don‚Äôt let earlier cells override it.

#### Option B: keep it **Section 2 scoped**

If you want it inside section2 artifacts, then you must also *write it there*:

```
SEC2_ARTIFACTS_DIR / "registry" / "dataset_version_registry.csv"
```

### Quick fix that won‚Äôt fight your notebook state

In 2.0.3, instead of trusting whatever `REGISTRY_DIR` happens to be, resolve the version registry from multiple known locations:

```python
registry_candidates = [
    (REGISTRY_DIR / "dataset_version_registry.csv") if "REGISTRY_DIR" in globals() and REGISTRY_DIR else None,
    (ARTIFACTS_DIR / "registry" / "dataset_version_registry.csv"),
    (SEC2_ARTIFACTS_DIR / "registry" / "dataset_version_registry.csv") if "SEC2_ARTIFACTS_DIR" in globals() else None,
]

registry_candidates = [p for p in registry_candidates if p is not None]
version_registry_path = next((p for p in registry_candidates if p.exists()), None)

if version_registry_path:
    reg_df = pd.read_csv(version_registry_path)
    version_id = str(reg_df["version_id"].iloc[-1]) if (not reg_df.empty and "version_id" in reg_df.columns) else None
else:
    print("‚ö†Ô∏è Dataset version registry not found. Looked in:")
    for p in registry_candidates:
        print("   -", p)
```

That will immediately tell you **where it actually exists** (or confirm it doesn‚Äôt exist anywhere).

### üí°üí° What you should think about doing

* Decide if `dataset_version_registry.csv` is **project-level truth** (my vote) ‚Üí keep it under `ARTIFACTS_DIR/registry/`.
* Treat `REGISTRY_DIR` as **one canonical global**, set once in bootstrap, and never redefine it in later sections.
* If you keep both ‚Äúlevel registry‚Äù and ‚Äúsection2 registry‚Äù, rename them so you never mix them up:

  * `PROJECT_REGISTRY_DIR` (or `LEVEL_REGISTRY_DIR`)
  * `SEC2_REGISTRY_DIR`

If you paste what your Section 1 ‚Äúdataset version registry‚Äù writer cell uses for its path, I can tell you exactly which of the two conventions you accidentally implemented.
