># Q: Does this need a fix? Why does status=WARN?

```py
# NEW 2.1.7 üß± Column-Type Alignment Audit + dtype baseline Snapshot (no coercion) | def(reporting) no C()
print("\n2.1.7 üß± Column-Type Alignment Audit (no coercion)")

# Guards
assert "df" in globals(), "‚ùå df not found. Run Section 2.0 first."
assert "CONFIG" in globals(), "‚ùå CONFIG not found. Run 2.0.1‚Äì2.0.2."
assert "REPORTS_DIR" in globals(), "‚ùå REPORTS_DIR missing. Run 2.0.1."
assert "SECTION2_REPORT_PATH" in globals(), "‚ùå SECTION2_REPORT_PATH missing. Run 2.0.1."

# Ensure Section 2 reports dir exists
SEC2_REPORTS_DIR   = REPORTS_DIR   / "section2"
SEC2_ARTIFACTS_DIR = ARTIFACTS_DIR / "section2"
SEC2_REPORTS_DIR.mkdir(parents=True, exist_ok=True)
SEC2_ARTIFACTS_DIR.mkdir(parents=True, exist_ok=True)

# Config: expected dtypes (may be empty)
expected_dtypes_cfg = CONFIG.get("SCHEMA_EXPECTED_DTYPES")
if expected_dtypes_cfg is None:
    expected_dtypes = {}
elif isinstance(expected_dtypes_cfg, dict):
    expected_dtypes = dict(expected_dtypes_cfg)
else:
    # Defensive: unexpected shape
    expected_dtypes = {}

baseline_rows = []
enforce_rows = []

for col, exp in expected_dtypes.items():
    present = col in df.columns
    actual_dtype = str(df[col].dtype) if present else None
    expected_str = str(exp)

    # Baseline row (no coercion, just capture current state)
    baseline_rows.append(
        {
            "column": col,
            "original_dtype": actual_dtype,
            "post_enforcement_dtype": actual_dtype,  # unchanged in audit-only mode
            "coercion_attempted": False,
            "coercion_ok": None,
            "n_coercion_fail": None,
            "sample_fail_values": None,
        }
    )

    # Enforcement row (expected vs actual)
    matches_expected = (actual_dtype == expected_str) if actual_dtype is not None else False

    note = ""
    if not present:
        note = "missing_in_df"

    enforce_rows.append(
        {
            "column": col,
            "expected_dtype": expected_str,
            "actual_dtype": actual_dtype,
            "matches_expected": bool(matches_expected),
            "present_in_df": bool(present),
            "note": note,
        }
    )

# ---- Write baseline + enforcement reports (atomic) --------------------------
dtype_baseline_df = pd.DataFrame(
    baseline_rows,
    columns=[
        "column",
        "original_dtype",
        "post_enforcement_dtype",
        "coercion_attempted",
        "coercion_ok",
        "n_coercion_fail",
        "sample_fail_values",
    ],
)

dtype_enforcement_df = pd.DataFrame(
    enforce_rows,
    columns=[
        "column",
        "expected_dtype",
        "actual_dtype",
        "matches_expected",
        "present_in_df",
        "note",
    ],
)

dtype_baseline_path = SEC2_REPORTS_DIR / "dtype_baseline_report.csv"
tmp = dtype_baseline_path.with_suffix(".tmp.csv")
dtype_baseline_df.to_csv(tmp, index=False)
os.replace(tmp, dtype_baseline_path)

dtype_enforcement_path = SEC2_REPORTS_DIR / "dtype_enforcement_report.csv"
tmp = dtype_enforcement_path.with_suffix(".tmp.csv")
dtype_enforcement_df.to_csv(tmp, index=False)
os.replace(tmp, dtype_enforcement_path)

print(f"üßæ Wrote baseline ‚Üí {dtype_baseline_path}")
print(f"üßæ Wrote enforcement ‚Üí {dtype_enforcement_path}")
display(dtype_enforcement_df.head(20))

# ---- Unified Section 2 diagnostics row (2.1.7A) -----------------------------
if len(expected_dtypes) == 0:
    status_217A = "SKIP"
    n_checked_217A = 0
    n_mismatched_217A = 0
else:
    n_checked_217A = len(expected_dtypes)
    if dtype_enforcement_df.empty:
        status_217A = "WARN"
        n_mismatched_217A = n_checked_217A
    else:
        ok_mask = dtype_enforcement_df["matches_expected"].fillna(False) & \
                  dtype_enforcement_df["present_in_df"].fillna(False)
        n_mismatched_217A = int(n_checked_217A - ok_mask.sum())
        status_217A = "OK" if n_mismatched_217A == 0 else "WARN"

sec2_chunk_217A = pd.DataFrame(
    {
        "section": ["2.1.7A"],
        "section_name": ["Column-type alignment audit (no coercion)"],
        "check": ["Schema-driven dtype alignment (read-only)"],
        "level": ["info"],
        "n_columns_checked": [n_checked_217A],
        "n_mismatched": [n_mismatched_217A],
        "status": [status_217A],
        "detail": [
            f"Baseline: {dtype_baseline_path.name}; "
            f"Enforcement: {dtype_enforcement_path.name}"
        ],
        "timestamp": [pd.Timestamp.now()],
    }
)

log_section_completion(
    "2.1.7A",
    status_217A,
    checked=n_checked_217A,
    mismatched=n_mismatched_217A,
)

display(sec2_chunk_217A)
append_sec2(sec2_chunk_217A, SECTION2_REPORT_PATH)
SECTION2_APPEND_SECTIONS.add("2.1.7A")

print(
    f"‚úÖ [2.1.7A] Dtype alignment audit | "
    f"status={status_217A} | "
    f"checked={n_checked_217A}, mismatched={n_mismatched_217A}"
)

2.1.7 üß± Column-Type Alignment Audit (no coercion)
üßæ Wrote baseline ‚Üí /Users/b/DATA/PROJECTS/Telco/Level_3/resources/reports/section2/dtype_baseline_report.csv
üßæ Wrote enforcement ‚Üí /Users/b/DATA/PROJECTS/Telco/Level_3/resources/reports/section2/dtype_enforcement_report.csv

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>column</th>
      <th>expected_dtype</th>
      <th>actual_dtype</th>
      <th>matches_expected</th>
      <th>present_in_df</th>
      <th>note</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>customerID</td>
      <td>string</td>
      <td>category</td>
      <td>False</td>
      <td>True</td>
      <td></td>
    </tr>
    <tr>
      <th>1</th>
      <td>Churn_flag</td>
      <td>Int64</td>
      <td>Int8</td>
      <td>False</td>
      <td>True</td>
      <td></td>
    </tr>
    <tr>
      <th>2</th>
      <td>SeniorCitizen</td>
      <td>Int64</td>
      <td>int64</td>
      <td>False</td>
      <td>True</td>
      <td></td>
    </tr>
    <tr>
      <th>3</th>
      <td>tenure</td>
      <td>Int64</td>
      <td>int64</td>
      <td>False</td>
      <td>True</td>
      <td></td>
    </tr>
    <tr>
      <th>4</th>
      <td>MonthlyCharges</td>
      <td>float64</td>
      <td>float64</td>
      <td>True</td>
      <td>True</td>
      <td></td>
    </tr>
    <tr>
      <th>5</th>
      <td>TotalCharges</td>
      <td>float64</td>
      <td>float64</td>
      <td>True</td>
      <td>True</td>
      <td></td>
    </tr>
    <tr>
      <th>6</th>
      <td>gender</td>
      <td>string</td>
      <td>category</td>
      <td>False</td>
      <td>True</td>
      <td></td>
    </tr>
    <tr>
      <th>7</th>
      <td>Partner</td>
      <td>string</td>
      <td>category</td>
      <td>False</td>
      <td>True</td>
      <td></td>
    </tr>
    <tr>
      <th>8</th>
      <td>Dependents</td>
      <td>string</td>
      <td>category</td>
      <td>False</td>
      <td>True</td>
      <td></td>
    </tr>
    <tr>
      <th>9</th>
      <td>PhoneService</td>
      <td>string</td>
      <td>category</td>
      <td>False</td>
      <td>True</td>
      <td></td>
    </tr>
    <tr>
      <th>10</th>
      <td>MultipleLines</td>
      <td>string</td>
      <td>category</td>
      <td>False</td>
      <td>True</td>
      <td></td>
    </tr>
    <tr>
      <th>11</th>
      <td>InternetService</td>
      <td>string</td>
      <td>category</td>
      <td>False</td>
      <td>True</td>
      <td></td>
    </tr>
    <tr>
      <th>12</th>
      <td>OnlineSecurity</td>
      <td>string</td>
      <td>category</td>
      <td>False</td>
      <td>True</td>
      <td></td>
    </tr>
    <tr>
      <th>13</th>
      <td>OnlineBackup</td>
      <td>string</td>
      <td>category</td>
      <td>False</td>
      <td>True</td>
      <td></td>
    </tr>
    <tr>
      <th>14</th>
      <td>DeviceProtection</td>
      <td>string</td>
      <td>category</td>
      <td>False</td>
      <td>True</td>
      <td></td>
    </tr>
    <tr>
      <th>15</th>
      <td>TechSupport</td>
      <td>string</td>
      <td>category</td>
      <td>False</td>
      <td>True</td>
      <td></td>
    </tr>
    <tr>
      <th>16</th>
      <td>StreamingTV</td>
      <td>string</td>
      <td>category</td>
      <td>False</td>
      <td>True</td>
      <td></td>
    </tr>
    <tr>
      <th>17</th>
      <td>StreamingMovies</td>
      <td>string</td>
      <td>category</td>
      <td>False</td>
      <td>True</td>
      <td></td>
    </tr>
    <tr>
      <th>18</th>
      <td>Contract</td>
      <td>string</td>
      <td>category</td>
      <td>False</td>
      <td>True</td>
      <td></td>
    </tr>
    <tr>
      <th>19</th>
      <td>PaperlessBilling</td>
      <td>string</td>
      <td>category</td>
      <td>False</td>
      <td>True</td>
      <td></td>
    </tr>
  </tbody>
</table>
</div>
‚úÖ [2.1.7A] | status=WARN | checked=22 | mismatched=20
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>section</th>
      <th>section_name</th>
      <th>check</th>
      <th>level</th>
      <th>n_columns_checked</th>
      <th>n_mismatched</th>
      <th>status</th>
      <th>detail</th>
      <th>timestamp</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2.1.7A</td>
      <td>Column-type alignment audit (no coercion)</td>
      <td>Schema-driven dtype alignment (read-only)</td>
      <td>info</td>
      <td>22</td>
      <td>20</td>
      <td>WARN</td>
      <td>Baseline: dtype_baseline_report.csv; Enforceme...</td>
      <td>2025-12-09 19:16:17.760596</td>
    </tr>
  </tbody>
</table>
</div>

üßæ Appended diagnostics ‚Üí /Users/b/DATA/PROJECTS/Telco/Level_3/resources/reports/section2/section2_data_quality_20251209_181006.csv
‚úÖ [2.1.7A] Dtype alignment audit | status=WARN | checked=22, mismatched=20
```

---

># SOLUTION:

Short answer: the cell is doing exactly what you asked it to do üôÇ ‚Äî and the `WARN` is coming from **real mismatches** between your `CONFIG` dtypes and the actual `df` dtypes, not from a bug.

---

## 1. Why is `status = WARN`?

This block decides the status:

```python
if len(expected_dtypes) == 0:
    status_217A = "SKIP"
    n_checked_217A = 0
    n_mismatched_217A = 0
else:
    n_checked_217A = len(expected_dtypes)
    if dtype_enforcement_df.empty:
        status_217A = "WARN"
        n_mismatched_217A = n_checked_217A
    else:
        ok_mask = dtype_enforcement_df["matches_expected"].fillna(False) & \
                  dtype_enforcement_df["present_in_df"].fillna(False)
        n_mismatched_217A = int(n_checked_217A - ok_mask.sum())
        status_217A = "OK" if n_mismatched_217A == 0 else "WARN"
```

* You have `len(expected_dtypes) = 22` ‚Üí `n_checked_217A = 22`.
* In `dtype_enforcement_df`, only **2** columns match (`MonthlyCharges`, `TotalCharges`).
* That gives `n_mismatched_217A = 22 ‚àí 2 = 20`.
* Because `n_mismatched_217A > 0`, you get `status_217A = "WARN"`.

You can see this directly from the table:

* `MonthlyCharges` ‚Üí `expected_dtype = float64`, `actual_dtype = float64`, `matches_expected = True`
* `TotalCharges` ‚Üí `float64` vs `float64` ‚Üí `True`
* Everything else is `False` (e.g. `customerID: expected string, actual category`; `Churn_flag: expected Int64, actual Int8`, etc.).

So the cell is behaving exactly as coded: **any mismatch at all ‚Üí WARN**.

---

## 2. Does this need a *fix*?

Two separate questions:

### A) Is the **code** wrong?

No ‚Äî the logic is correct for a strict alignment audit:

* It reads `SCHEMA_EXPECTED_DTYPES` from `CONFIG`.
* It compares that to the current `df[col].dtype` string.
* It reports mismatches and summarizes them.

So there‚Äôs no bug here.

### B) Is the **result** (lots of mismatches) ‚Äúbad‚Äù?

That depends on what you intend `SCHEMA_EXPECTED_DTYPES` to describe:

1. **If `SCHEMA_EXPECTED_DTYPES` is meant to describe the RAW IBM Telco CSV**
   Then this audit should be run **right after reading the raw file**, *before* you convert anything to `category`, `Int8`, etc.

   What‚Äôs happening in your output:

   * `customerID` is `category`, but config says `string`.
   * All service columns (Partner, Dependents, InternetService, etc.) are `category`, but config says `string`.
   * `Churn_flag` is `Int8`, but config says `Int64`.
   * `SeniorCitizen` is `int64`, but config says `Int64` (pandas‚Äô nullable vs non-nullable int mismatch).

   That tells me: you‚Äôve already **coerced** dtypes somewhere upstream (e.g., cast to category or downcast ints), but `SCHEMA_EXPECTED_DTYPES` still describes a different stage (raw semantic dtypes).

   In that case:

   * The WARN is **correct** and informative: ‚ÄúWe‚Äôve drifted away from our schema contract at this point.‚Äù
   * No code change is required, but you may want to:

     * Run 2.1.7 **earlier** in the pipeline (immediately after load), or
     * Adjust the config to match your **post-clean** dtypes instead of the raw ones.

2. **If `SCHEMA_EXPECTED_DTYPES` is meant to describe the *current* cleaned df**
   Then the schema is out of sync with reality. You have two main options:

   * **Option 1 ‚Äì Update the CONFIG to match actual dtypes**

     For example, in `project_config.yaml`, change:

     ```yaml
     SCHEMA_EXPECTED_DTYPES:
       customerID: string
       gender: string
       ...
     ```

     to something closer to your current frame:

     ```yaml
     SCHEMA_EXPECTED_DTYPES:
       customerID: category
       gender: category
       Partner: category
       ...
       Churn_flag: Int8
       SeniorCitizen: int64
     ```

     Once CONFIG matches `df.dtypes`, rerun 2.1.7 ‚Üí `status` will flip to `OK`.

   * **Option 2 ‚Äì Compare on ‚Äúdtype families‚Äù instead of exact strings**

     If you care more about *‚Äúthis is categorical‚Äù* vs *‚Äúthis is numeric‚Äù* than about exactly `string` vs `category`, you could loosen the check:

     ```python
     def normalize_family(dtype_str: str) -> str:
         d = dtype_str.lower()
         if any(x in d for x in ["int", "float", "complex"]):
             return "numeric"
         if "category" in d:
             return "categorical"
         if "bool" in d:
             return "boolean"
         if "datetime" in d or "date" in d:
             return "datetime"
         return "string_like"
     ```

     And then define `matches_expected` as:

     ```python
     expected_family = normalize_family(expected_str)
     actual_family   = normalize_family(actual_dtype) if actual_dtype is not None else None
     matches_expected = (actual_family == expected_family) if actual_family is not None else False
     ```

     That way, `string` vs `category` ‚Üí both become `"categorical"` (or `"string_like"` vs `"categorical"`, depending how you map it), and you can decide whether that counts as a match.

---

## 3. Do you *have* to change anything right now?

If your goal for 2.1.7A is:

> ‚ÄúTell me, at this stage, how far my dtypes have drifted from the schema in CONFIG.‚Äù

‚Ä¶then **no change is required**. `WARN` is the correct status: 20 of 22 columns are not exactly what CONFIG says.

If your goal is more like:

> ‚ÄúSanity-check that things aren‚Äôt wildly wrong, but don‚Äôt scream if I downcast or use categories,‚Äù

‚Ä¶then:

* üí°üí° Either run 2.1.7 earlier (against raw dtypes),
* üí°üí° Or relax the match to work on dtype families (numeric vs categorical vs boolean, etc.),
* üí°üí° Or update the config to reflect your *cleaned* dtypes instead of the raw IBM schema.

If you tell me which of those you want (raw-contract audit vs cleaned-contract audit vs loose-family check), I can rewrite the bottom part of 2.1.7A to match that intention exactly.
