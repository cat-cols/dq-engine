># QUESTION: why is the config not found?

```py
# SECTION 2.3 | SETUP: Numeric Distribution & Outlier Detection.

# Guards
required = [
    ("df", "‚ùå df not found. Run Section 2.0 first."),
    ("CONFIG", "‚ùå CONFIG not found. Run 2.0.1‚Äì2.0.2."),
    ("SECTION2_REPORT_PATH", "‚ùå SECTION2_REPORT_PATH missing. Run 2.0.1."),
    ("SEC2_REPORTS_DIR", "‚ùå SEC2_REPORTS_DIR missing. Run 2.0.0/2.0.1 first."),
    ("SEC2_ARTIFACTS_DIR", "‚ùå SEC2_ARTIFACTS_DIR missing. Run 2.0.0 first."),
]

missing = [msg for name, msg in required if name not in globals() or globals().get(name) is None]

if missing:
    raise RuntimeError("Section preflight failed:\n" + "\n".join(missing))

# Resolve Section 2.3 report dir (prevents NameError)
if "sec23_reports_dir" not in globals() or sec23_reports_dir is None:
    if "SEC2_REPORT_DIRS" in globals() and isinstance(SEC2_REPORT_DIRS, dict) and "2.3" in SEC2_REPORT_DIRS:
        sec23_reports_dir = SEC2_REPORT_DIRS["2.3"]
    elif "SEC2_REPORTS_DIR" in globals():
        sec23_reports_dir = (SEC2_REPORTS_DIR / "2_3").resolve()
    elif "REPORTS_DIR" in globals():
        sec23_reports_dir = (REPORTS_DIR / "section2" / "2_3").resolve()
    else:
        sec23_reports_dir = Path("section2_reports/2_3").resolve()

sec23_reports_dir.mkdir(parents=True, exist_ok=True)

# 2.3.x
CONFIG = ensure_globals({"CONFIG": {}}, label="2.3")

# TODO: confirm baseline paths correct
# Canonical baseline location (project-scoped, not run-scoped)
BASELINE_DIR_23 = (PROJECT_ROOT / "resources" / "artifacts" / "baseline").resolve()
BASELINE_DIR_23.mkdir(parents=True, exist_ok=True)

BASELINE_NUMERIC_PROFILE_PATH_23 = (BASELINE_DIR_23 / "numeric_profile_baseline.csv").resolve()

# ‚îÄ‚îÄ Run-scoped section directories (canonical)
sec23_reports_dir   = (Path(SEC2_REPORTS_DIR)   / "2_3").resolve()
sec23_artifacts_dir = (Path(SEC2_ARTIFACTS_DIR) / "2_3").resolve()

# Figures: prefer run-scoped FIGURES_DIR if defined, else derive from run root
if "FIGURES_DIR" in globals() and FIGURES_DIR:
    sec23_figures_dir = (Path(FIGURES_DIR) / "2_3").resolve()
else:
    # SEC2_REPORTS_DIR = runs/<RUN_ID>/reports, so parent is runs/<RUN_ID>
    run_root = Path(SEC2_REPORTS_DIR).resolve().parent
    sec23_figures_dir = (run_root / "figures" / "2_3").resolve()

sec23_reports_dir.mkdir(parents=True, exist_ok=True)
sec23_artifacts_dir.mkdir(parents=True, exist_ok=True)
sec23_figures_dir.mkdir(parents=True, exist_ok=True)

print("üìÅ 2.3 reports  ‚Üí", sec23_reports_dir)
print("üìÅ 2.3 artifacts‚Üí", sec23_artifacts_dir)
print("üìÅ 2.3 figures  ‚Üí", sec23_figures_dir)
print("üìÅ 2.3 baseline numeric profile ‚Üí", BASELINE_NUMERIC_PROFILE_PATH_23)

# ‚îÄ‚îÄ Canonical inputs from 2.2 live in run-scoped reports/2_2/
sec22_reports_dir = (Path(SEC2_REPORTS_DIR) / "2_2").resolve()
type_map_path = sec22_reports_dir / "column_type_map.json"
if not type_map_path.exists():
    raise FileNotFoundError(
        f"‚ùå column_type_map.json not found at {type_map_path}. "
        "Run Section 2.2 (2.2.1‚Äì2.2.7) first."
    )

with open(type_map_path, "r", encoding="utf-8") as f:
    column_type_map = json.load(f)

# Load type detection summary (for later joins)
type_summary_path = sec22_reports_dir / "type_detection_summary.csv"
type_det_df = None
if type_summary_path.exists():
    type_det_df = pd.read_csv(type_summary_path)

# Optional coercion log from 2.2.2
coercion_log_path = sec22_reports_dir / "coercion_log.csv"
coercion_info = {}
if coercion_log_path.exists():
    _coercion_df = pd.read_csv(coercion_log_path)
    if "column" in _coercion_df.columns:
        coercion_info = (
            _coercion_df
            .set_index("column")[["attempted", "success_ratio"]]
            .to_dict(orient="index")
        )
    else:
        print("‚ö†Ô∏è coercion_log.csv has no 'column' field; skipping coercion join.")
else:
    print("‚ÑπÔ∏è No coercion_log.csv found (2.2.2) ‚Äî proceeding without coercion metadata.")

# ‚îÄ‚îÄ Determine numeric columns from column_type_map
numeric_cols = []
for col, meta in column_type_map.items():
    if col not in df.columns:
        continue
    if meta.get("type_group") == "numeric":
        numeric_cols.append(col)

numeric_cols = sorted(set(numeric_cols))
n_rows_23, _ = df.shape

if not numeric_cols:
    print("‚ö†Ô∏è No numeric columns detected from column_type_map ‚Äî 2.3 will run empty.")

# Config knobs for exclusions
try:
    exclude_ids = bool(C("NUMERIC_CHECKS.EXCLUDE_IDS", True))
except Exception:
    exclude_ids = True

try:
    exclude_targets = bool(C("NUMERIC_CHECKS.EXCLUDE_TARGETS", False))
except Exception:
    exclude_targets = False

numeric_cols_filtered = []
excluded = 0
for col in numeric_cols:
    meta = column_type_map.get(col, {}) or {}
    is_id = bool(meta.get("is_id", False))
    is_target = bool(meta.get("is_target", False))
    if exclude_ids and is_id:
        excluded += 1
        continue
    if exclude_targets and is_target:
        excluded += 1
        continue
    numeric_cols_filtered.append(col)

numeric_cols = numeric_cols_filtered

print(f"üìå 2.3 will inspect {len(numeric_cols)} numeric columns.")
print(f"   excluded {excluded} numeric columns (ids/targets by config).")
print("2.3 üî¢ PART A setup complete")

# # ‚îÄ‚îÄ Canonical ‚Äúwrite targets‚Äù for downstream 2.3 cells
# # Use these in 2.3.1+ instead of NUMERIC_DIR / TYPE_DET_DIR etc.
# NUMERIC_REPORTS_DIR_23   = sec23_reports_dir
# NUMERIC_ARTIFACTS_DIR_23 = sec23_artifacts_dir
# NUMERIC_FIGURES_DIR_23   = sec23_figures_dir

# # OLD PART A | 2.3.1-2.3.6 SETUP Core Numeric Integrity & Outliers üî¢ Core Numeric Validation
# print("\n2.3 üî¢ Numeric Integrity & Outliers ‚Äî PART A Core Numeric Validation")

# # ‚îÄ‚îÄ Shared guards / paths
# assert "df" in globals(), "‚ùå df is not defined. Run Section 1 & 2.1/2.2 first."
# assert "SEC2_REPORTS_DIR" in globals() and SEC2_REPORTS_DIR, "‚ùå SEC2_REPORTS_DIR missing."
# assert "SECTION2_REPORT_PATH" in globals(), "‚ùå SECTION2_REPORT_PATH missing (2.0.1)."

# # Create section 2.3 Directory
# sec23_reports_dir = (SEC2_REPORTS_DIR / "2_3").resolve()
# sec23_reports_dir.mkdir(parents=True, exist_ok=True)

# sec23_artifacts_dir = (SEC2_ARTIFACTS_DIR / "2_3").resolve()
# sec23_artifacts_dir.mkdir(parents=True, exist_ok=True)

# sec23_dir = (SEC2_REPORTS_DIR / "numeric_integrity").resolve()
# sec23_dir.mkdir(parents=True, exist_ok=True)

# TYPE_DET_DIR = (SEC2_ARTIFACTS_DIR / "type_detection").resolve()
# TYPE_DET_DIR.mkdir(parents=True, exist_ok=True)

# NUMERIC_DIR = (SEC2_REPORTS_DIR / "numeric_integrity").resolve()
# NUMERIC_DIR.mkdir(parents=True, exist_ok=True)

# type_map_path = TYPE_DET_DIR / "column_type_map.json"
# if not type_map_path.exists():
#     raise FileNotFoundError(
#         f"‚ùå column_type_map.json not found at {type_map_path}. "
#         "Run Section 2.2 (2.2.1‚Äì2.2.7) first."
#     )

# with open(type_map_path, "r", encoding="utf-8") as f:
#     column_type_map = json.load(f)

# # Load type detection summary (for later joins)
# type_summary_path = TYPE_DET_DIR / "type_detection_summary.csv"
# type_det_df = None
# if type_summary_path.exists():
#     type_det_df = pd.read_csv(type_summary_path)

# # Optional coercion log from 2.2.2
# coercion_log_path = TYPE_DET_DIR / "coercion_log.csv"
# coercion_info = {}
# if coercion_log_path.exists():
#     _coercion_df = pd.read_csv(coercion_log_path)
#     if "column" in _coercion_df.columns:
#         coercion_info = (
#             _coercion_df
#             .set_index("column")[["attempted", "success_ratio"]]
#             .to_dict(orient="index")
#         )
#     else:
#         print("‚ö†Ô∏è coercion_log.csv has no 'column' field; skipping coercion join.")
# else:
#     print("‚ÑπÔ∏è No coercion_log.csv found (2.2.2) ‚Äî proceeding without coercion metadata.")

# # Determine numeric columns from column_type_map
# numeric_cols = []
# for col, meta in column_type_map.items():
#     if col not in df.columns:
#         continue
#     if meta.get("type_group") == "numeric":
#         numeric_cols.append(col)

# numeric_cols = sorted(set(numeric_cols))
# n_rows_23, _ = df.shape

# if not numeric_cols:
#     print("‚ö†Ô∏è No numeric columns detected from column_type_map ‚Äî 2.3 will run empty.")

# # Config knobs for exclusions
# try:
#     exclude_ids = bool(C("NUMERIC_CHECKS.EXCLUDE_IDS", True))
# except Exception:
#     exclude_ids = True

# try:
#     exclude_targets = bool(C("NUMERIC_CHECKS.EXCLUDE_TARGETS", False))
# except Exception:
#     exclude_targets = False

# numeric_cols_filtered = []
# for col in numeric_cols:
#     meta = column_type_map.get(col, {})
#     is_id = bool(meta.get("is_id", False))
#     is_target = bool(meta.get("is_target", False))
#     if exclude_ids and is_id:
#         continue
#     if exclude_targets and is_target:
#         continue
#     numeric_cols_filtered.append(col)

# numeric_cols = numeric_cols_filtered
# print(f"üìå 2.3 will inspect {len(numeric_cols)} numeric columns.")
# print(f"            exclude {len(numeric_cols) - len(numeric_cols_filtered)} numeric columns.")
# print("2.3 üî¢ PART A Core Numeric Validation Numeric Integrity & Outliers setup complete")

output:
‚ö†Ô∏è 2.3: CONFIG not found in globals(); using default.
üìÅ 2.3 reports  ‚Üí /Users/b/DATA/PROJECTS/Telco/_T2/Level_3/runs/20260118_233238/reports/2_3
üìÅ 2.3 artifacts‚Üí /Users/b/DATA/PROJECTS/Telco/_T2/Level_3/runs/20260118_233238/artifacts/2_3
üìÅ 2.3 figures  ‚Üí /Users/b/DATA/PROJECTS/Telco/_T2/Level_3/runs/20260118_233238/figures/2_3
üìÅ 2.3 baseline numeric profile ‚Üí /Users/b/DATA/PROJECTS/Telco/resources/artifacts/baseline/numeric_profile_baseline.csv
üìå 2.3 will inspect 5 numeric columns.
   excluded 0 numeric columns (ids/targets by config).
2.3 üî¢ PART A setup complete
```

># SOLUTION:

Because **your Section 2.3 cell is looking for `CONFIG` in notebook `globals()`**, but you moved config binding into the **module** (`dq_engine.utils.config`) via `_BOUND_CONFIG`. Those are two different universes:

* Notebook globals: `globals()["CONFIG"]`
* Module-bound config: `dq_engine.utils.config._BOUND_CONFIG` (accessed via `C()`)

So the warning:

> `‚ö†Ô∏è 2.3: CONFIG not found in globals(); using default.`

is coming from **your own helper** (`ensure_globals({"CONFIG": {}}, ...)`) which is doing exactly what you told it to do: ‚Äúif CONFIG isn‚Äôt in globals, create an empty dict.‚Äù

Meanwhile your `C(...)` *still works* **as long as you called `load_and_bind_config()` earlier in the session**.

### The key idea

Once you adopt **module-bound config**, you should stop treating `CONFIG` as a required notebook-global guard.

---

## Fix options (pick one)

### Option A (recommended): Stop requiring global `CONFIG` at all

Change your ‚ÄúGuards‚Äù list to require the config module to be bound, not `CONFIG`.

Do this at the top of Section 2.3:

```python
import dq_engine.utils.config as cfg

# Ensure config is bound (module-scoped), not notebook-scoped
if cfg.config_source() == "(unbound)":
    raise RuntimeError("‚ùå Config is unbound. Run your config bind cell first.")

C = cfg.C  # convenience alias
```

Then **remove** this from your required list:

```python
("CONFIG", "‚ùå CONFIG not found. Run 2.0.1‚Äì2.0.2.")
```

‚Ä¶and delete this line entirely (it‚Äôs forcing empty CONFIG into globals):

```python
CONFIG = ensure_globals({"CONFIG": {}}, label="2.3")
```

This makes your pipeline consistent: config lives in one place (the module), and `C()` is the single accessor.

---

### Option B: Keep the old `CONFIG` global for backwards compatibility

If you still have code that expects `CONFIG` to exist as a dict in the notebook, set it explicitly **from the bound module**:

```python
import dq_engine.utils.config as cfg

# if not bound, bind it here or fail fast
if cfg.config_source() == "(unbound)":
    cfg.load_and_bind_config(PROJECT_CONFIG_PATH)

CONFIG = cfg.C("", {})  # not ideal; see below
```

Better:

```python
import dq_engine.utils.config as cfg
from dq_engine.utils.config import load_and_bind_config

CONFIG = load_and_bind_config(PROJECT_CONFIG_PATH)
C = cfg.C
```

This makes `CONFIG` exist in globals, so your old guards won‚Äôt complain, but you‚Äôre still ultimately loading/binding via the module.

---

## Why your printout still ‚Äúworked‚Äù even with the warning

Because your ‚Äúexcluded ids/targets by config‚Äù logic is wrapped in try/except and uses `C(...)`. If `C` is bound, you‚Äôll still get real values. The warning is only about **the notebook global variable** `CONFIG`, not about the bound config.

---

## üí°üí° One more cleanup (it‚Äôll save you future headaches)

Your `required` guard list still assumes `CONFIG` is a primitive dependency like `df`. But config is now a *service* provided by the module. So your preflight should be something like:

* `df` exists
* run directories exist
* config module is bound

That‚Äôs the new invariant.

---

If you implement Option A, your Section 2.x notebooks will stop oscillating between ‚Äúmodule config‚Äù and ‚Äúglobal CONFIG‚Äù and the whole engine gets calmer, like a well-fed python.
