># Why?

```python
# PART 2) Resolve PROJECT_ROOT / LEVEL_ROOT and wire src/ into sys.path
# NOTE: see 'Telco/_T2/Level_3/docs/_meta/2.0.0_PART2_Assumptions_Design.md'

# ============================================================
# üí°üí° Be LENIENT about config_path here.
# - Validate PROJECT_ROOT exists (hard requirement)
# - DO NOT require config_path to exist yet (moves can break it)
# - We'll use config_path ONLY to infer tier/level if present
# ============================================================

CURRENT_PATH = Path.cwd().resolve()

TIER_LEVEL = globals().get("TIER_LEVEL", "_T2")
LEVEL_NAME = globals().get("LEVEL_NAME", "Level_3")

# --- init so we never NameError ---
PROJECT_ROOT = None
LEVEL_ROOT = None
SRC_ROOT = None

setup_summary_path = None
config_path_from_summary = None
raw_project_root = None
raw_cfg_path = None

# 1) If setup_summary already exists in memory, try to use it
if "setup_summary" in globals() and isinstance(globals().get("setup_summary"), dict):
    setup_summary_path = "<memory>"
    try:
        raw_project_root = setup_summary.get("project", {}).get("project_root")
        raw_cfg_path     = setup_summary.get("project", {}).get("config_path")

        # ‚úÖ strict about project_root (must exist)
        if raw_project_root:
            pr_path = Path(raw_project_root).expanduser().resolve()
            if pr_path.exists():
                PROJECT_ROOT = pr_path

        # üí°üí° lenient about config path (store even if stale / moved)
        if raw_cfg_path:
            config_path_from_summary = Path(raw_cfg_path).expanduser().resolve()

    except Exception:
        PROJECT_ROOT = None
        config_path_from_summary = None


# 2) If we still don't have a PROJECT_ROOT, locate setup_summary.json on disk
if PROJECT_ROOT is None:
    # 2a) walk upwards from CURRENT_PATH looking for setup_summary.json
    for parent in [CURRENT_PATH] + list(CURRENT_PATH.parents):
        cand = parent / "setup_summary.json"
        if cand.exists():
            setup_summary_path = cand
            break

    # 2b) fallback: use .git to locate repo, then search common places
    if setup_summary_path is None:
        for parent in [CURRENT_PATH] + list(CURRENT_PATH.parents):
            if (parent / ".git").exists():
                PROJECT_ROOT = parent
                break

        if PROJECT_ROOT is None:
            raise FileNotFoundError(
                f"‚ùå Could not locate setup_summary.json from {CURRENT_PATH} and no .git found for fallback."
            )

        LEVEL_ROOT_guess = (PROJECT_ROOT / TIER_LEVEL / LEVEL_NAME).resolve()
        candidates = [
            PROJECT_ROOT / "setup_summary.json",
            LEVEL_ROOT_guess / "resources" / "artifacts" / "setup_summary.json",
            LEVEL_ROOT_guess / "resources" / "reports"   / "setup_summary.json",
            LEVEL_ROOT_guess / "resources" / "artifacts" / "section1" / "setup_summary.json",
            LEVEL_ROOT_guess / "resources" / "reports"   / "section1" / "setup_summary.json",
        ]
        setup_summary_path = next((p for p in candidates if p.exists()), None)

        if setup_summary_path is None:
            search_root = LEVEL_ROOT_guess / "resources"
            if search_root.exists():
                hits = list(search_root.rglob("setup_summary.json"))
                setup_summary_path = max(hits, key=lambda p: p.stat().st_mtime) if hits else None

    if setup_summary_path is None:
        raise FileNotFoundError("‚ùå setup_summary.json not found (truth missing and fallback search failed).")

    # Load setup_summary from disk
    with Path(setup_summary_path).open("r", encoding="utf-8") as f:
        setup_summary = json.load(f)

    raw_project_root = setup_summary.get("project", {}).get("project_root")
    raw_cfg_path     = setup_summary.get("project", {}).get("config_path")

    if not raw_project_root:
        raise KeyError("‚ùå setup_summary['project']['project_root'] missing.")

    # ‚úÖ strict about PROJECT_ROOT
    PROJECT_ROOT = Path(raw_project_root).expanduser().resolve()
    if not PROJECT_ROOT.exists():
        raise FileNotFoundError(f"‚ùå PROJECT_ROOT invalid: {PROJECT_ROOT}")

    # üí°üí° lenient about config path (may be stale)
    if raw_cfg_path:
        config_path_from_summary = Path(raw_cfg_path).expanduser().resolve()


# 3) Infer tier/level from config path if present
# üí°üí° This is the ONLY reason we use config_path here in Part 2.
if config_path_from_summary is not None:
    for part in config_path_from_summary.parts:
        if isinstance(part, str) and part.startswith("_T"):
            TIER_LEVEL = part
        elif isinstance(part, str) and part.startswith("Level_"):
            LEVEL_NAME = part

LEVEL_ROOT = (PROJECT_ROOT / TIER_LEVEL / LEVEL_NAME).resolve()
SRC_ROOT   = (LEVEL_ROOT / "src").resolve()

# Guards
if not LEVEL_ROOT.exists():
    raise FileNotFoundError(f"‚ùå LEVEL_ROOT does not exist: {LEVEL_ROOT}")

# sys.path wiring
if SRC_ROOT.exists() and str(SRC_ROOT) not in sys.path:
    sys.path.insert(0, str(SRC_ROOT))

# Level-wide shared roots (correct for Part 2)
REPORTS_DIR   = (LEVEL_ROOT / "resources" / "reports").resolve()
ARTIFACTS_DIR = (LEVEL_ROOT / "resources" / "artifacts").resolve()
FIGURES_DIR   = (LEVEL_ROOT / "resources" / "figures").resolve()
MODELS_DIR    = (LEVEL_ROOT / "resources" / "models").resolve()
OUTPUTS_DIR   = (LEVEL_ROOT / "resources" / "outputs").resolve()

for d in [REPORTS_DIR, ARTIFACTS_DIR, FIGURES_DIR, MODELS_DIR, OUTPUTS_DIR]:
    d.mkdir(parents=True, exist_ok=True)

RAW_DATA = None  # placeholder; resolve after CONFIG in Part 6

# Prints
print("‚úÖ Loaded setup_summary from:", setup_summary_path)
print("üìÑ project_root (raw):", raw_project_root)
print("üìÑ config_path (raw): ", raw_cfg_path)
print("üìÑ config_path_from_summary (resolved, may be stale):", config_path_from_summary, "üí°üí°")
print("üìÅ PROJECT_ROOT:", PROJECT_ROOT)
print("üìÅ LEVEL_ROOT:  ", LEVEL_ROOT)
print("üìÅ SRC_ROOT:    ", SRC_ROOT, "(added)" if str(SRC_ROOT) in sys.path else "(not added)")
print("üìÅ CURRENT_PATH:", CURRENT_PATH)

# PART 5) Create Section 2 shared directories (created ONCE, reused by all 2.x)

assert "PROJECT_ROOT" in globals() and PROJECT_ROOT, "‚ùå PROJECT_ROOT missing."
assert "LEVEL_ROOT" in globals() and LEVEL_ROOT, "‚ùå LEVEL_ROOT missing."
assert "CONFIG" in globals() and isinstance(CONFIG, dict), "‚ùå CONFIG missing or invalid."
assert "setup_summary" in globals() and isinstance(setup_summary, dict), "‚ùå setup_summary missing."

# 1) Pull Section-1 recorded paths (as fallbacks)
FIGURES_DIR   = Path(setup_summary["paths"]["figures_dir"]).expanduser().resolve()
MODELS_DIR    = Path(setup_summary["paths"]["models_dir"]).expanduser().resolve()
OUTPUTS_DIR   = Path(setup_summary["paths"]["outputs_dir"]).expanduser().resolve()

# 2) Resolve dataset paths from CONFIG (RAW_DATA_DIR / PROCESSED_DIR / RAW_DATA) + mkdir overrides
paths_block    = CONFIG.get("PATHS", {}) or {}
datasets_block = CONFIG.get("DATASETS", {}) or {}
telco_ds       = datasets_block.get("TELCO", {}) or {}

raw_data_dir_cfg  = paths_block.get("RAW_DATA_DIR")
processed_dir_cfg = paths_block.get("PROCESSED_DIR")
raw_file_cfg      = telco_ds.get("RAW_FILE")
processed_file_cfg = telco_ds.get("PROCESSED_FILE")  # NOTE: optional

# RAW_DATA_DIR: safe default + override
RAW_DATA_DIR = (PROJECT_ROOT / "data" / "raw").resolve()
if raw_data_dir_cfg:
    _raw_dir = Path(raw_data_dir_cfg).expanduser()
    RAW_DATA_DIR = (_raw_dir if _raw_dir.is_absolute() else (PROJECT_ROOT / _raw_dir).resolve())
print("üìÅ RAW_DATA_DIR:", RAW_DATA_DIR)

# 4) PROCESSED_DIR: safe default + override
PROCESSED_DIR = (PROJECT_ROOT / "data" / "processed").resolve()
if processed_dir_cfg:
    _proc_dir = Path(processed_dir_cfg).expanduser()
    PROCESSED_DIR = (_proc_dir if _proc_dir.is_absolute() else (PROJECT_ROOT / _proc_dir).resolve())
print("üìÅ PROCESSED_DIR:", PROCESSED_DIR, "\n")

# --- Canonical Section 2 roots (do NOT clobber level-wide roots) ---
# 5) Ensure SEC2_REPORTS_DIR exists (must happen before SECTION2_REPORT_PATH)
SEC2_REPORTS_DIR = globals().get("SEC2_REPORTS_DIR", (REPORTS_DIR / "section2").resolve())
print("üìÅ REPORTS_DIR:", REPORTS_DIR)

# 6) Ensure SEC2_ARTIFACTS_DIR exists (must happen before SECTION2_ARTIFACTS_PATH)
SEC2_ARTIFACTS_DIR = globals().get("SEC2_ARTIFACTS_DIR", (ARTIFACTS_DIR / "section2").resolve())
print("üìÅ SEC2_ARTIFACTS_DIR:", SEC2_ARTIFACTS_DIR)

# 7) Ensure REGISTRY_DIR exists (must happen before SECTION2_ARTIFACTS_PATH)
# 7) Canonical (project-wide) registry directory (truth)
REGISTRY_DIR = globals().get("REGISTRY_DIR", (ARTIFACTS_DIR / "registry").resolve())
REGISTRY_DIR.mkdir(parents=True, exist_ok=True)
print("üìÅ REGISTRY_DIR (project-wide):", REGISTRY_DIR)

DATASET_VERSION_REGISTRY_PATH = globals().get(
    "DATASET_VERSION_REGISTRY_PATH",
    (REGISTRY_DIR / "dataset_version_registry.csv").resolve()
)
print("üìÑ DATASET_VERSION_REGISTRY_PATH:", DATASET_VERSION_REGISTRY_PATH)

# Optional: Section-2 scoped registry dir (NOT for dataset_version_registry.csv)
SEC2_REGISTRY_DIR = globals().get(
    "SEC2_REGISTRY_DIR",
    (SEC2_ARTIFACTS_DIR / "registry").resolve()
)
SEC2_REGISTRY_DIR.mkdir(parents=True, exist_ok=True)
print("üìÅ SEC2_REGISTRY_DIR (section2-only):", SEC2_REGISTRY_DIR)

# 8) Ensure LOGS_DIR exists
LOGS_DIR = globals().get("LOGS_DIR", (SEC2_REPORTS_DIR / "logs").resolve())
LOGS_DIR.mkdir(parents=True, exist_ok=True)
print("üìÅ LOGS_DIR:", LOGS_DIR)

# for d in [RAW_DATA_DIR, PROCESSED_DIR, FIGURES_DIR, MODELS_DIR, OUTPUTS_DIR, SEC2_REPORTS_DIR, SEC2_ARTIFACTS_DIR, REGISTRY_DIR]:
#     d.mkdir(parents=True, exist_ok=True)
#     if d.exists():
#         print("üìÅ Directory Created:", d)
#     else:
#         print("üìÅ Directory Creation Failed:", d)
# print("\nüìÅ Directories: {CREATED}")

# Derive RAW_DATA from RAW_DATA_DIR + RAW_FILE if provided
# RAW_DATA V2 (derive from RAW_DATA_DIR + RAW_FILE; fallback to Section 1 recorded raw_data)
raw_from_summary = Path(setup_summary["paths"]["raw_data"]).expanduser().resolve()
RAW_DATA = (RAW_DATA_DIR / raw_file_cfg).resolve() if raw_file_cfg else raw_from_summary
print("\nüìÑ RAW_DATA:", RAW_DATA)
if not RAW_DATA.exists():
    print("‚ö†Ô∏è RAW_DATA does not exist:", RAW_DATA)
    raise FileNotFoundError("‚ùå RAW_DATA does not exist.")

# TODO: keep or set up parquet?
# Optional: processed filename from config
processed_file_cfg = telco_ds.get("PROCESSED_FILE")  # e.g. "telco_clean.parquet" or "telco_clean.csv"

# PROCESSED_DATA: derive if PROCESSED_FILE provided, else default to a sensible name
# (config wins; else choose a default that matches RAW suffix)
if processed_file_cfg:
    PROCESSED_DATA = (PROCESSED_DIR / processed_file_cfg).resolve()
else:
    # pick ONE convention and stick to it
    PROCESSED_DATA = (PROCESSED_DIR / "telco_processed.parquet").resolve()
if not PROCESSED_DATA.exists():
    default_suffix = ".parquet" if RAW_DATA.suffix.lower() in {".parquet", ".pq"} else ".csv"
    PROCESSED_DATA = (PROCESSED_DIR / f"telco_processed{default_suffix}").resolve()
print("üìÑ PROCESSED_DATA:", PROCESSED_DATA)

# Ensure dirs exist *after* overrides
for d in [
    RAW_DATA_DIR, PROCESSED_DIR, FIGURES_DIR, MODELS_DIR, OUTPUTS_DIR,
    SEC2_REPORTS_DIR, SEC2_ARTIFACTS_DIR, REGISTRY_DIR, LOGS_DIR,
    SEC2_REGISTRY_DIR,
]:
    d.mkdir(parents=True, exist_ok=True)

print("\n...Directories CREATED!")‚ÄúTruth conflict‚Äù issue: Part 5 overwrites FIGURES_DIR / MODELS_DIR / OUTPUTS_DIR

This is one of the biggest structural problems:

In Part 2, you define level-scoped:

FIGURES_DIR = LEVEL_ROOT/resources/figures
MODELS_DIR  = LEVEL_ROOT/resources/models
OUTPUTS_DIR = LEVEL_ROOT/resources/outputs


In Part 5, you replace them using Section 1 summary:

FIGURES_DIR = Path(setup_summary["paths"]["figures_dir"])
...


So your ‚Äútruth‚Äù flips mid-bootstrap.

‚úÖ Decide ONE policy and enforce it:

Option A (recommended for Level isolation)

üí°üí° Keep Level-scoped roots as truth (Part 2), and treat Section 1 paths as fallback only if missing.
# Only fallback if your Part 2 paths weren't set
FIGURES_DIR = globals().get("FIGURES_DIR") or Path(setup_summary["paths"]["figures_dir"]).resolve()
MODELS_DIR  = globals().get("MODELS_DIR")  or Path(setup_summary["paths"]["models_dir"]).resolve()
OUTPUTS_DIR = globals().get("OUTPUTS_DIR") or Path(setup_summary["paths"]["outputs_dir"]).resolve()
```

># SOLUTION:

You‚Äôre reading it exactly right: **Part 5 is currently clobbering the ‚Äútruth‚Äù you established in Part 2.** Let‚Äôs fix it cleanly.

Below is a **step-by-step** patch that enforces **Option A (Level isolation)**:

---

## Step 1) Decide the truth

**Truth = Level roots (Part 2):**

* `LEVEL_ROOT/resources/figures`
* `LEVEL_ROOT/resources/models`
* `LEVEL_ROOT/resources/outputs`

**Section 1 setup_summary paths = fallback only** (used *only* if the Level roots somehow aren‚Äôt set).

That‚Äôs Option A.

---

## Step 2) Make Part 2 ‚Äúown‚Äù the level roots (you already do this ‚úÖ)

This part is already good in your Part 2:

```python
FIGURES_DIR   = (LEVEL_ROOT / "resources" / "figures").resolve()
MODELS_DIR    = (LEVEL_ROOT / "resources" / "models").resolve()
OUTPUTS_DIR   = (LEVEL_ROOT / "resources" / "outputs").resolve()
```

So we don‚Äôt touch Part 2.

---

## Step 3) Replace the clobber lines in Part 5

Right now Part 5 does this (‚ùå remove/replace):

```python
# 1) Pull Section-1 recorded paths (as fallbacks)
FIGURES_DIR   = Path(setup_summary["paths"]["figures_dir"]).expanduser().resolve()
MODELS_DIR    = Path(setup_summary["paths"]["models_dir"]).expanduser().resolve()
OUTPUTS_DIR   = Path(setup_summary["paths"]["outputs_dir"]).expanduser().resolve()
```

### Replace with this (‚úÖ fallback only, never overwrite truth)

```python
# 1) Section-1 recorded paths (fallbacks ONLY ‚Äî do not overwrite Level truth)
fig_from_summary = setup_summary.get("paths", {}).get("figures_dir")
mod_from_summary = setup_summary.get("paths", {}).get("models_dir")
out_from_summary = setup_summary.get("paths", {}).get("outputs_dir")

if "FIGURES_DIR" not in globals() or globals().get("FIGURES_DIR") is None:
    FIGURES_DIR = Path(fig_from_summary).expanduser().resolve() if fig_from_summary else (LEVEL_ROOT / "resources" / "figures").resolve()

if "MODELS_DIR" not in globals() or globals().get("MODELS_DIR") is None:
    MODELS_DIR = Path(mod_from_summary).expanduser().resolve() if mod_from_summary else (LEVEL_ROOT / "resources" / "models").resolve()

if "OUTPUTS_DIR" not in globals() or globals().get("OUTPUTS_DIR") is None:
    OUTPUTS_DIR = Path(out_from_summary).expanduser().resolve() if out_from_summary else (LEVEL_ROOT / "resources" / "outputs").resolve()

# Normalize to Paths (guards against strings)
FIGURES_DIR = Path(FIGURES_DIR).resolve()
MODELS_DIR  = Path(MODELS_DIR).resolve()
OUTPUTS_DIR = Path(OUTPUTS_DIR).resolve()
```

**What this does:**

* If Part 2 already set `FIGURES_DIR`, Part 5 **leaves it alone**.
* If for some reason `FIGURES_DIR` wasn‚Äôt set, Part 5 tries setup_summary; if missing, it falls back to Level roots anyway.

---

## Step 4) (Recommended) Assert the policy explicitly

Right after the above, add:

```python
# üí°üí° Policy assertion: Level isolation
_expected_fig = (LEVEL_ROOT / "resources" / "figures").resolve()
_expected_mod = (LEVEL_ROOT / "resources" / "models").resolve()
_expected_out = (LEVEL_ROOT / "resources" / "outputs").resolve()

if FIGURES_DIR != _expected_fig or MODELS_DIR != _expected_mod or OUTPUTS_DIR != _expected_out:
    print("‚ö†Ô∏è Level isolation policy violated; resetting to Level roots.")
    FIGURES_DIR = _expected_fig
    MODELS_DIR  = _expected_mod
    OUTPUTS_DIR = _expected_out
```

This makes the intent unmissable and prevents future accidental overwrites.

---

## Step 5) Keep your mkdir loop (it‚Äôs correct)

This stays good:

```python
for d in [
    RAW_DATA_DIR, PROCESSED_DIR, FIGURES_DIR, MODELS_DIR, OUTPUTS_DIR,
    SEC2_REPORTS_DIR, SEC2_ARTIFACTS_DIR, REGISTRY_DIR, LOGS_DIR,
    SEC2_REGISTRY_DIR,
]:
    d.mkdir(parents=True, exist_ok=True)
```

---

## Step 6) Quick sanity check prints (optional but useful)

Add:

```python
print("‚úÖ FIGURES_DIR truth:", FIGURES_DIR)
print("‚úÖ MODELS_DIR truth: ", MODELS_DIR)
print("‚úÖ OUTPUTS_DIR truth:", OUTPUTS_DIR)
```

---

# What to delete vs add (super clear)

### Delete in Part 5:

* The 3 lines that overwrite FIGURES_DIR/MODELS_DIR/OUTPUTS_DIR from setup_summary

### Add in Part 5:

* The fallback-only block (Step 3)
* (Optional but strong) the policy assertion (Step 4)

---

## üí°üí° One extra design note (important)

If you really want **section1 artifacts to be ‚Äúproject-wide‚Äù** while **section2 is ‚Äúlevel-wide,‚Äù** then setup_summary should *not* be used to source these directories at all‚Äîonly for **project_root** and maybe **raw_data** provenance.

Your Option A is the cleanest story for recruiters too: **each Level is reproducible and self-contained.**

If you paste your updated Part 5 after this change, I‚Äôll scan it for any remaining ‚Äútruth flips‚Äù (there are a couple similar patterns with `RAW_DATA` vs config vs summary).
