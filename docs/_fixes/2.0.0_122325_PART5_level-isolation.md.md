
>
># Q: What has caused the message "Level isolation policy violated; resetting to Level roots."?
>

---

That message fires because at the moment this block runs, at least one of these is **not exactly** the Level-scoped expected path:

* `FIGURES_DIR != (LEVEL_ROOT / "resources" / "figures")`
* `MODELS_DIR  != (LEVEL_ROOT / "resources" / "models")`
* `OUTPUTS_DIR != (LEVEL_ROOT / "resources" / "outputs")`

In your code, that can happen in two common ways:

### 1) You imported ‚ÄúSection-1 recorded paths‚Äù from `setup_summary`

These lines can set the dirs to something **outside** the Level:

```python
fig_from_summary = setup_summary.get("paths", {}).get("figures_dir")
mod_from_summary = setup_summary.get("paths", {}).get("models_dir")
out_from_summary = setup_summary.get("paths", {}).get("outputs_dir")

FIGURES_DIR = Path(fig_from_summary)...  # etc
```

If `setup_summary["paths"]["figures_dir"]` was recorded earlier as a project-wide location (or a different Level/tier), you‚Äôll violate the isolation check and get reset.

### 2) Those globals were already set earlier in the notebook

Even if `setup_summary` is fine, you only set `FIGURES_DIR/MODELS_DIR/OUTPUTS_DIR` **if** they‚Äôre missing/None:

```python
if "FIGURES_DIR" not in globals() or globals().get("FIGURES_DIR") is None:
    ...
```

So if an earlier cell set `FIGURES_DIR` to something else (common when re-running notebooks out of order), you‚Äôll hit the policy reset.

---

## Pinpoint it instantly (add this debug print right before the `if`)

```python
print("DEBUG FIGURES_DIR:", FIGURES_DIR)
print("DEBUG MODELS_DIR :", MODELS_DIR)
print("DEBUG OUTPUTS_DIR:", OUTPUTS_DIR)
print("EXPECTED FIGURES :", _expected_fig)
print("EXPECTED MODELS  :", _expected_mod)
print("EXPECTED OUTPUTS :", _expected_out)
```

That will show you exactly which one is ‚Äúoff‚Äù and what it was.

---

## If you want this to stop happening (and still keep the fallback idea)

Right now you *compute* from summary, but then you *override to Level roots anyway*. So you can simplify and remove ambiguity:

**Option A (strict isolation always):** don‚Äôt use summary for these at all:

```python
FIGURES_DIR = (LEVEL_ROOT / "resources" / "figures").resolve()
MODELS_DIR  = (LEVEL_ROOT / "resources" / "models").resolve()
OUTPUTS_DIR = (LEVEL_ROOT / "resources" / "outputs").resolve()
```

**Option B (allow summary only if it matches the Level):**

```python
def _use_if_matches(candidate, expected):
    if not candidate:
        return expected
    c = Path(candidate).expanduser().resolve()
    return c if c == expected else expected

FIGURES_DIR = _use_if_matches(fig_from_summary, _expected_fig)
MODELS_DIR  = _use_if_matches(mod_from_summary, _expected_mod)
OUTPUTS_DIR = _use_if_matches(out_from_summary, _expected_out)
```

That way you won‚Äôt even print the warning ‚Äî you‚Äôll silently enforce isolation.

If you paste the `setup_summary["paths"]` dict (just that part), I can tell you exactly which recorded path is triggering the reset.

---

># A:

```python
# PART 5) Create Section 2 shared directories (created ONCE, reused by all 2.x)

assert "PROJECT_ROOT" in globals() and PROJECT_ROOT, "‚ùå PROJECT_ROOT missing."
assert "LEVEL_ROOT" in globals() and LEVEL_ROOT, "‚ùå LEVEL_ROOT missing."
assert "CONFIG" in globals() and isinstance(CONFIG, dict), "‚ùå CONFIG missing or invalid."
assert "setup_summary" in globals() and isinstance(setup_summary, dict), "‚ùå setup_summary missing."

# 1) Section-1 recorded paths (fallbacks ONLY ‚Äî do not overwrite Level truth)
fig_from_summary = setup_summary.get("paths", {}).get("figures_dir")
mod_from_summary = setup_summary.get("paths", {}).get("models_dir")
out_from_summary = setup_summary.get("paths", {}).get("outputs_dir")

if "FIGURES_DIR" not in globals() or globals().get("FIGURES_DIR") is None:
    FIGURES_DIR = Path(fig_from_summary).expanduser().resolve() if fig_from_summary else (LEVEL_ROOT / "resources" / "figures").resolve()

if "MODELS_DIR" not in globals() or globals().get("MODELS_DIR") is None:
    MODELS_DIR = Path(mod_from_summary).expanduser().resolve() if mod_from_summary else (LEVEL_ROOT / "resources" / "models").resolve()

if "OUTPUTS_DIR" not in globals() or globals().get("OUTPUTS_DIR") is None:
    OUTPUTS_DIR = Path(out_from_summary).expanduser().resolve() if out_from_summary else (LEVEL_ROOT / "resources" / "outputs").resolve()

# Normalize to Paths (guards against strings)
FIGURES_DIR = Path(FIGURES_DIR).resolve()
MODELS_DIR  = Path(MODELS_DIR).resolve()
OUTPUTS_DIR = Path(OUTPUTS_DIR).resolve()

# üí°üí° Policy assertion: Level isolation
_expected_fig = (LEVEL_ROOT / "resources" / "figures").resolve()
_expected_mod = (LEVEL_ROOT / "resources" / "models").resolve()
_expected_out = (LEVEL_ROOT / "resources" / "outputs").resolve()

if FIGURES_DIR != _expected_fig or MODELS_DIR != _expected_mod or OUTPUTS_DIR != _expected_out:
    print("‚ö†Ô∏è Level isolation policy violated; resetting to Level roots.")
    FIGURES_DIR = _expected_fig
    MODELS_DIR  = _expected_mod
    OUTPUTS_DIR = _expected_out

# 2) Resolve dataset paths from CONFIG (RAW_DATA_DIR / PROCESSED_DIR / RAW_DATA) + mkdir overrides
paths_block    = CONFIG.get("PATHS", {}) or {}
datasets_block = CONFIG.get("DATASETS", {}) or {}
telco_ds       = datasets_block.get("TELCO", {}) or {}

raw_data_dir_cfg  = paths_block.get("RAW_DATA_DIR")
processed_dir_cfg = paths_block.get("PROCESSED_DIR")
raw_file_cfg      = telco_ds.get("RAW_FILE")
processed_file_cfg = telco_ds.get("PROCESSED_FILE")  # NOTE: optional

# RAW_DATA_DIR: safe default + override
RAW_DATA_DIR = (PROJECT_ROOT / "data" / "raw").resolve()
if raw_data_dir_cfg:
    _raw_dir = Path(raw_data_dir_cfg).expanduser()
    RAW_DATA_DIR = (_raw_dir if _raw_dir.is_absolute() else (PROJECT_ROOT / _raw_dir).resolve())
print("üìÅ RAW_DATA_DIR:", RAW_DATA_DIR)

# 4) PROCESSED_DIR: safe default + override
PROCESSED_DIR = (PROJECT_ROOT / "data" / "processed").resolve()
if processed_dir_cfg:
    _proc_dir = Path(processed_dir_cfg).expanduser()
    PROCESSED_DIR = (_proc_dir if _proc_dir.is_absolute() else (PROJECT_ROOT / _proc_dir).resolve())
print("üìÅ PROCESSED_DIR:", PROCESSED_DIR, "\n")

# --- Canonical Section 2 roots (do NOT clobber level-wide roots) ---
# 5) Ensure SEC2_REPORTS_DIR exists (must happen before SECTION2_REPORT_PATH)
# reports/artifacts/figures roots for section2
SEC2_REPORTS_DIR = globals().get("SEC2_REPORTS_DIR", (REPORTS_DIR / "section2").resolve())
SEC2_REPORTS_DIR.mkdir(parents=True, exist_ok=True)
print("üìÅ SEC2_REPORTS_DIR:", SEC2_REPORTS_DIR)

# 6) Ensure SEC2_ARTIFACTS_DIR exists
SEC2_ARTIFACTS_DIR = globals().get("SEC2_ARTIFACTS_DIR", (ARTIFACTS_DIR / "section2").resolve())
SEC2_ARTIFACTS_DIR.mkdir(parents=True, exist_ok=True)
print("üìÅ SEC2_ARTIFACTS_DIR:", SEC2_ARTIFACTS_DIR)

# 6) Ensure SEC2_FIGURES_DIR exists
SEC2_FIGURES_DIR = globals().get("SEC2_FIGURES_DIR", (FIGURES_DIR / "section2").resolve())
SEC2_FIGURES_DIR.mkdir(parents=True, exist_ok=True)
print("üìÅ SEC2_FIGURES_DIR:", SEC2_FIGURES_DIR)

# 8)Canonical "latest shared" Section 2 artifacts folder (cross-section inputs) ----
# This is where sections publish "latest" artifacts for other sections to consume.
SEC2_LATEST_DIR = globals().get("SEC2_LATEST_DIR", (SEC2_ARTIFACTS_DIR / "_latest").resolve())
SEC2_LATEST_DIR.mkdir(parents=True, exist_ok=True)
print("üìÅ SEC2_LATEST_DIR:", SEC2_LATEST_DIR)

# 9) Ensure SEC2_DIR exists
SEC2_DIR = (ARTIFACTS_DIR / "section2").resolve()
SEC2_DIR.mkdir(parents=True, exist_ok=True)

# section2 models live under level models (keeps isolation + avoids path confusion)
SEC2_MODELS_DIR = globals().get("SEC2_MODELS_DIR", (MODELS_DIR / "section2").resolve())
SEC2_MODELS_DIR.mkdir(parents=True, exist_ok=True)

# 7) Categorical roots (chapter-style, stable, do NOT depend on Part 6)
CATEGORICAL_DIR = globals().get("CATEGORICAL_DIR", (SEC2_ARTIFACTS_DIR / "categorical").resolve())
CATEGORICAL_DIR.mkdir(parents=True, exist_ok=True)

# 8) Categorical figures
CATEGORICAL_FIG_DIR = globals().get("CATEGORICAL_FIG_DIR", (SEC2_FIGURES_DIR / "categorical").resolve())
CATEGORICAL_FIG_DIR.mkdir(parents=True, exist_ok=True)
print("üìÅ CATEGORICAL_DIR:", CATEGORICAL_DIR)
print("üìÅ CATEGORICAL_FIG_DIR:", CATEGORICAL_FIG_DIR)


# 9) Canonical file path for 2.5.11 output (OK to define in bootsrap; do not require it exists)
ANOMALY_CONTEXT_PATH = (SEC2_ARTIFACTS_DIR / "logic_anomaly_context.parquet").resolve()
ANOMALY_DIR = ANOMALY_CONTEXT_PATH.parent
print("‚úÖ ANOMALY_CONTEXT_PATH=", ANOMALY_CONTEXT_PATH)

# 10) Ensure REGISTRY_DIR exists (must happen before SECTION2_ARTIFACTS_PATH)
# (Canonical (project-wide) registry directory (truth)
REGISTRY_DIR = globals().get("REGISTRY_DIR", (ARTIFACTS_DIR / "registry").resolve())
REGISTRY_DIR.mkdir(parents=True, exist_ok=True)
print("üìÅ REGISTRY_DIR (project-wide):", REGISTRY_DIR)

DATASET_VERSION_REGISTRY_PATH = globals().get(
    "DATASET_VERSION_REGISTRY_PATH",
    (REGISTRY_DIR / "dataset_version_registry.csv").resolve()
)
print("üìÑ DATASET_VERSION_REGISTRY_PATH:", DATASET_VERSION_REGISTRY_PATH)

# 10) Optional: Section-2 scoped registry dir (NOT for dataset_version_registry.csv)
SEC2_REGISTRY_DIR = globals().get(
    "SEC2_REGISTRY_DIR",
    (SEC2_ARTIFACTS_DIR / "registry").resolve()
)
SEC2_REGISTRY_DIR.mkdir(parents=True, exist_ok=True)
print("üìÅ SEC2_REGISTRY_DIR (section2-only):", SEC2_REGISTRY_DIR)

# 10) Ensure LOGS_DIR exists
LOGS_DIR = globals().get("LOGS_DIR", (SEC2_REPORTS_DIR / "logs").resolve())
LOGS_DIR.mkdir(parents=True, exist_ok=True)
print("üìÅ LOGS_DIR:", LOGS_DIR)

# for d in [RAW_DATA_DIR, PROCESSED_DIR, FIGURES_DIR, MODELS_DIR, OUTPUTS_DIR, SEC2_REPORTS_DIR, SEC2_ARTIFACTS_DIR, REGISTRY_DIR]:
#     d.mkdir(parents=True, exist_ok=True)
#     if d.exists():
#         print("üìÅ Directory Created:", d)
#     else:
#         print("üìÅ Directory Creation Failed:", d)
# print("\nüìÅ Directories: {CREATED}")

# 11) Derive RAW_DATA from RAW_DATA_DIR + RAW_FILE if provided
# RAW_DATA V2 (derive from RAW_DATA_DIR + RAW_FILE; fallback to Section 1 recorded raw_data)
raw_from_summary = Path(setup_summary["paths"]["raw_data"]).expanduser().resolve()
RAW_DATA = (RAW_DATA_DIR / raw_file_cfg).resolve() if raw_file_cfg else raw_from_summary
print("\nüìÑ RAW_DATA:", RAW_DATA)
if not RAW_DATA.exists():
    print("‚ö†Ô∏è RAW_DATA does not exist:", RAW_DATA)
    raise FileNotFoundError("‚ùå RAW_DATA does not exist.")

# 12) Canonical master Section 2 report (shared sink for all 2.x)
SECTION2_REPORT_PATH = globals().get(
    "SECTION2_REPORT_PATH",
    (SEC2_REPORTS_DIR / "section2_report.csv").resolve()
)

    # Make sure parent dir exists
SECTION2_REPORT_PATH.parent.mkdir(parents=True, exist_ok=True)
print("üìÑ SECTION2_REPORT_PATH:", SECTION2_REPORT_PATH)

# TODO: keep or set up parquet?
# Optional: processed filename from config
processed_file_cfg = telco_ds.get("PROCESSED_FILE")  # e.g. "telco_clean.parquet" or "telco_clean.csv"

# 13) PROCESSED_DATA: derive if PROCESSED_FILE provided, else default to a sensible name
# (config wins; else choose a default that matches RAW suffix)
if processed_file_cfg:
    PROCESSED_DATA = (PROCESSED_DIR / processed_file_cfg).resolve()
else:
    # pick ONE convention and stick to it
    PROCESSED_DATA = (PROCESSED_DIR / "telco_processed.parquet").resolve()
if not PROCESSED_DATA.exists():
    default_suffix = ".parquet" if RAW_DATA.suffix.lower() in {".parquet", ".pq"} else ".csv"
    PROCESSED_DATA = (PROCESSED_DIR / f"telco_processed{default_suffix}").resolve()
print("üìÑ PROCESSED_DATA:", PROCESSED_DATA)

# 13) Ensure dirs exist *after* overrides
for d in [
    RAW_DATA_DIR, PROCESSED_DIR, FIGURES_DIR, MODELS_DIR, OUTPUTS_DIR,
    SEC2_REPORTS_DIR, SEC2_ARTIFACTS_DIR, REGISTRY_DIR, LOGS_DIR,
    SEC2_REGISTRY_DIR, CATEGORICAL_DIR, CATEGORICAL_FIG_DIR, SEC2_DIR,
]:
    d.mkdir(parents=True, exist_ok=True)


print("\n...Directories CREATED!")

‚ö†Ô∏è Level isolation policy violated; resetting to Level roots.
üìÅ RAW_DATA_DIR: /Users/b/DATA/PROJECTS/Telco/data/_raw
üìÅ PROCESSED_DIR: /Users/b/DATA/PROJECTS/Telco/data/processed 

üìÅ SEC2_REPORTS_DIR: /Users/b/DATA/PROJECTS/Telco/_T2/Level_3/resources/reports/section2
üìÅ SEC2_ARTIFACTS_DIR: /Users/b/DATA/PROJECTS/Telco/_T2/Level_3/resources/artifacts/section2
üìÅ SEC2_FIGURES_DIR: /Users/b/DATA/PROJECTS/Telco/_T2/Level_3/resources/figures/section2
üìÅ SEC2_LATEST_DIR: /Users/b/DATA/PROJECTS/Telco/_T2/Level_3/resources/artifacts/section2/_latest
üìÅ CATEGORICAL_DIR: /Users/b/DATA/PROJECTS/Telco/_T2/Level_3/resources/artifacts/section2/categorical
üìÅ CATEGORICAL_FIG_DIR: /Users/b/DATA/PROJECTS/Telco/_T2/Level_3/resources/figures/section2/categorical
‚úÖ ANOMALY_CONTEXT_PATH= /Users/b/DATA/PROJECTS/Telco/_T2/Level_3/resources/artifacts/section2/logic_anomaly_context.parquet
üìÅ REGISTRY_DIR (project-wide): /Users/b/DATA/PROJECTS/Telco/_T2/Level_3/resources/artifacts/registry
üìÑ DATASET_VERSION_REGISTRY_PATH: /Users/b/DATA/PROJECTS/Telco/_T2/Level_3/resources/artifacts/registry/dataset_version_registry.csv
üìÅ SEC2_REGISTRY_DIR (section2-only): /Users/b/DATA/PROJECTS/Telco/_T2/Level_3/resources/artifacts/section2/registry
üìÅ LOGS_DIR: /Users/b/DATA/PROJECTS/Telco/_T2/Level_3/resources/reports/section2/logs

üìÑ RAW_DATA: /Users/b/DATA/PROJECTS/Telco/data/_raw/WA_Fn-UseC_-Telco-Customer-Churn.csv
üìÑ SECTION2_REPORT_PATH: /Users/b/DATA/PROJECTS/Telco/_T2/Level_3/resources/reports/section2/section2_report.csv
üìÑ PROCESSED_DATA: /Users/b/DATA/PROJECTS/Telco/data/processed/telco_processed.csv

...Directories CREATED!
```