# 2.3.7 ‚è±Ô∏è Temporal & Correlation Diagnostics
# "mini monitoring subsystem"
print("\n2.3.7 ‚è±Ô∏è Temporal & correlation diagnostics")

# Shared guards / paths
assert "df" in globals(), "‚ùå df is not defined. Run Section 1 & 2.1/2.2 first."
assert "REPORTS_DIR" in globals(), "‚ùå REPORTS_DIR missing."
assert "SECTION2_REPORT_PATH" in globals(), "‚ùå SECTION2_REPORT_PATH missing (2.0.1)."

NUMERIC_DIR = SEC2_REPORTS_DIR / "numeric"
NUMERIC_DIR.mkdir(parents=True, exist_ok=True)

# Try to load numeric_profile_df (preferred source for numeric features)
numeric_profile_path = NUMERIC_DIR / "numeric_profile_df.csv"
has_numeric_profile = numeric_profile_path.exists()

# Load column_type_map as fallback / metadata source
TYPE_DET_DIR = SEC2_REPORTS_DIR / "type_detection"
TYPE_DET_DIR.mkdir(parents=True, exist_ok=True)

type_map_path = TYPE_DET_DIR / "column_type_map.json"
if not type_map_path.exists():
    raise FileNotFoundError(
        f"‚ùå column_type_map.json not found at {type_map_path}. "
        "Run 2.2.1‚Äì2.2.7 first."
    )

with open(type_map_path, "r", encoding="utf-8") as f:
    column_type_map = json.load(f)

# Numeric feature list + model-eligible subset

numeric_cols_237 = []
for col_name, meta in column_type_map.items():
    if col_name not in df.columns:
        continue
    type_group = meta.get("type_group", "")
    hints = meta.get("hints", {}) or {}
    include_in_model = bool(hints.get("include_in_model", True))
    is_id = bool(meta.get("is_id", False))
    is_target = bool(meta.get("is_target", False))

    if type_group == "numeric" and include_in_model and (not is_id) and (not is_target):
        numeric_cols_237.append(col_name)

numeric_cols_237 = sorted(set(numeric_cols_237))

if has_numeric_profile:
    numeric_profile_df = pd.read_csv(numeric_profile_path)
    numeric_cols_from_profile = (
        numeric_profile_df["column"]
        .dropna()
        .astype("string")
        .unique()
        .tolist()
    )
    # intersect, but keep metadata-driven list as primary
    numeric_cols_237 = sorted(
        set(numeric_cols_237) | set(numeric_cols_from_profile)
    )

if not numeric_cols_237:
    print("‚ö†Ô∏è No numeric columns detected for 2.3.7 ‚Äî creating empty diagnostics artifacts.")

# Time column + temporal config
try:
    time_col_237 = C("TEMPORAL.TIME_COLUMN", "as_of_date") or "as_of_date"
except Exception:
    time_col_237 = "as_of_date"

has_time_col_237 = time_col_237 in df.columns

try:
    time_bucket_237 = C("TEMPORAL.TIME_BUCKET", "M") or "M"
except Exception:
    time_bucket_237 = "M"

try:
    z_thresh_bucket_237 = float(C("TEMPORAL.Z_THRESHOLD", 3.0))
except Exception:
    z_thresh_bucket_237 = 3.0

try:
    corr_window_237 = int(C("TEMPORAL.CORR_WINDOW", 3))
except Exception:
    corr_window_237 = 3

try:
    corr_delta_threshold_237 = float(C("TEMPORAL.CORR_DELTA_THRESHOLD", 0.3))
except Exception:
    corr_delta_threshold_237 = 0.3

# Example outcome metrics (you‚Äôll wire these to your real variables)
n_numeric_237          = len(numeric_cols_237)
n_time_buckets_237     = int(len(getattr(bucket_df_237, "index", [])))  # or your real frame
n_corr_pairs_237       = int(getattr(corr_drift_df_237, "shape", (0, 0))[0])
n_alerts_237           = int(getattr(alerts_237, "shape", (0, 0))[0])   # e.g. rows where |Œîcorr| > threshold
status_237             = "OK" if n_alerts_237 == 0 else "WARN"

summary_237 = pd.DataFrame([{
    "section":           "2.3.7",
    "section_name":      "Temporal & correlation diagnostics",
    "check":             "Mini monitoring: bucketed stats + correlation drift",
    "level":             "info",
    "status":            status_237,
    "time_column":       time_col_237,
    "time_bucket":       time_bucket_237,
    "z_threshold":       z_thresh_bucket_237,
    "corr_window":       corr_window_237,
    "corr_delta_thresh": corr_delta_threshold_237,
    "has_time_column":   has_time_col_237,
    "n_numeric_cols":    n_numeric_237,
    "n_time_buckets":    n_time_buckets_237,
    "n_corr_pairs":      n_corr_pairs_237,
    "n_alerts":          n_alerts_237,
    "detail":            "Temporal drift ‚Üí temporal_drift_*.csv; correlation drift ‚Üí corr_drift_*.csv",
    "timestamp":         pd.Timestamp.utcnow(),
}])

append_sec2(summary_237, SECTION2_REPORT_PATH)
display(summary_237)

---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
Cell In[294], line 95
     93 # Example outcome metrics (you‚Äôll wire these to your real variables)
     94 n_numeric_237          = len(numeric_cols_237)
---> 95 n_time_buckets_237     = int(len(getattr(bucket_df_237, "index", [])))  # or your real frame
     96 n_corr_pairs_237       = int(getattr(corr_drift_df_237, "shape", (0, 0))[0])
     97 n_alerts_237           = int(getattr(alerts_237, "shape", (0, 0))[0])   # e.g. rows where |Œîcorr| > threshold

NameError: name 'bucket_df_237' is not defined

---

># SOLUTION:

Nice, you wired in the summary ‚Äî the NameError is just Python tattling that we used variable *names* that don‚Äôt exist yet. üôÇ

Right now you have:

```python
n_time_buckets_237     = int(len(getattr(bucket_df_237, "index", [])))
n_corr_pairs_237       = int(getattr(corr_drift_df_237, "shape", (0, 0))[0])
n_alerts_237           = int(getattr(alerts_237, "shape", (0, 0))[0])
```

But **`bucket_df_237`, `corr_drift_df_237`, and `alerts_237` don‚Äôt exist at all**, so Python throws `NameError` *before* `getattr` can even run.

Until you actually build those DataFrames in 2.3.7, use a safe ‚Äúgrab from globals if present, else 0‚Äù pattern.

Drop this in **instead of** the lines that raised the error:

```python
# --- Aggregate outcome metrics safely ---------------------------------
n_numeric_237 = len(numeric_cols_237)

# Time buckets (if you later create a bucket_df_237)
bucket_df_237 = globals().get("bucket_df_237")
if isinstance(bucket_df_237, pd.DataFrame):
    n_time_buckets_237 = int(bucket_df_237.shape[0])
else:
    n_time_buckets_237 = 0

# Correlation drift pairs (if you later create corr_drift_df_237)
corr_drift_df_237 = globals().get("corr_drift_df_237")
if isinstance(corr_drift_df_237, pd.DataFrame):
    n_corr_pairs_237 = int(corr_drift_df_237.shape[0])
else:
    n_corr_pairs_237 = 0

# Alerts (e.g. rows where |Œîcorr| > threshold)
alerts_237 = globals().get("alerts_237")
if isinstance(alerts_237, pd.DataFrame):
    n_alerts_237 = int(alerts_237.shape[0])
else:
    n_alerts_237 = 0

status_237 = "OK" if n_alerts_237 == 0 else "WARN"
```

Then your summary block can stay as-is:

```python
summary_237 = pd.DataFrame([{
    "section":           "2.3.7",
    "section_name":      "Temporal & correlation diagnostics",
    "check":             "Mini monitoring: bucketed stats + correlation drift",
    "level":             "info",
    "status":            status_237,
    "time_column":       time_col_237,
    "time_bucket":       time_bucket_237,
    "z_threshold":       z_thresh_bucket_237,
    "corr_window":       corr_window_237,
    "corr_delta_thresh": corr_delta_threshold_237,
    "has_time_column":   has_time_col_237,
    "n_numeric_cols":    n_numeric_237,
    "n_time_buckets":    n_time_buckets_237,
    "n_corr_pairs":      n_corr_pairs_237,
    "n_alerts":          n_alerts_237,
    "detail":            "Temporal drift ‚Üí temporal_drift_*.csv; correlation drift ‚Üí corr_drift_*.csv",
    "timestamp":         pd.Timestamp.utcnow(),
}])

append_sec2(summary_237, SECTION2_REPORT_PATH)
display(summary_237)
print("‚úÖ 2.3.7 complete.")
```

This does two things:

1. **No NameErrors** if you haven‚Äôt built the full ‚Äúmini monitoring subsystem‚Äù yet.
2. As you implement `bucket_df_237`, `corr_drift_df_237`, and `alerts_237`, the summary row will automatically start reflecting real counts, without you touching this bottom block again.
