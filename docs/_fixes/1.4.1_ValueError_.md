
```py
# 1.4.1 Load Raw Dataset (CSV: Config-Driven, with READ_OPTS) / (PARQUET: )
print("1.4 üß© DATASET LOAD & VERSION VERIFICATION")
print(f"1.4.1) üì• Loading raw dataset from: {RAW_DATA}")
#FIXME: 1113_1013

if not RAW_DATA.exists():
    raise FileNotFoundError(f"‚ùå RAW_DATA file not found at {RAW_DATA}")

# Pull CSV read options from config (READ_OPTS is optional)
READ_OPTS = C("READ_OPTS", {}) or {}

suffix = RAW_DATA.suffix.lower()

---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Cell In[31], line 19
     17     df_raw = pd.read_parquet(RAW_DATA)
     18 else:
---> 19     raise ValueError(f"‚ùå Unsupported file format for RAW_DATA: {suffix}")
     21 n_rows, n_cols = df_raw.shape
     22 print(f"‚úÖ Loaded dataset: {n_rows:,} rows √ó {n_cols:,} columns")

ValueError: ‚ùå Unsupported file format for RAW_DATA:

if suffix == ".csv":
    print(f"   Using READ_OPTS from config: {READ_OPTS}")
    df_raw = pd.read_csv(RAW_DATA, **READ_OPTS)
elif suffix in {".parquet", ".pq"}:
    df_raw = pd.read_parquet(RAW_DATA)
else:
    raise ValueError(f"‚ùå Unsupported file format for RAW_DATA: {suffix}")

n_rows, n_cols = df_raw.shape
print(f"‚úÖ Loaded dataset: {n_rows:,} rows √ó {n_cols:,} columns")

---

># SOLUTION:

You just hit the *next* ‚Äúconfig vs intent‚Äù mismatch. This time it‚Äôs about **file vs directory**.

Right now:

* `RAW_DATA` is a **directory** (e.g. `‚Ä¶/data/_raw/`)
* Your loader is treating `RAW_DATA` as a **file path**

So:

```python
suffix = RAW_DATA.suffix.lower()  # ‚Üí "" (empty string, because it's a folder)
...
else:
    raise ValueError(f"‚ùå Unsupported file format for RAW_DATA: {suffix}")
```

Hence the error: unsupported format with a blank suffix.

---

## How I‚Äôd approach fixing this

### 1Ô∏è‚É£ Ask: what should `RAW_DATA` *mean*?

You have two reasonable options:

1. **Make `RAW_DATA` = directory path**, and have a *separate* ‚Äúraw file‚Äù path
2. **Make `RAW_DATA` = full file path**

Given your `project_config.yaml`:

```yaml
PATHS:
  RAW_DATA_DIR: "data/_raw/"

DATASETS:
  TELCO:
    RAW_FILE: "WA_Fn-UseC_-Telco-Customer-Churn.csv"
```

‚Ä¶you clearly meant:

* `RAW_DATA_DIR` ‚Üí folder
* `DATASETS.TELCO.RAW_FILE` ‚Üí filename

So I‚Äôd keep:

* `RAW_DATA_DIR` = directory
* Then build **full file path** in 1.4.1.

---

### 2Ô∏è‚É£ Keep 1.3.1 as ‚Äúdirectory resolver‚Äù

From earlier, we made `RAW_DATA` a dir. I‚Äôd actually rename that variable so it‚Äôs explicit:

```python
# In 1.3.1

raw_data_rel = C("PATHS.RAW_DATA", None)
if raw_data_rel is None:
    raw_data_rel = C("PATHS.RAW_DATA_DIR", None)
if raw_data_rel is None:
    raise KeyError(
        "‚ùå Missing config for RAW_DATA path. "
        "Tried PATHS.RAW_DATA and PATHS.RAW_DATA_DIR."
    )
RAW_DATA_DIR = PROJECT_ROOT / raw_data_rel
```

‚Ä¶and then use `RAW_DATA_DIR` everywhere that‚Äôs ‚Äúfolder-ish‚Äù.

üí°üí° *Improvement*: naming it `RAW_DATA_DIR` in code will save Future-You a lot of confusion vs. an ambiguous `RAW_DATA`.

---

### 3Ô∏è‚É£ In 1.4.1, build the **file path** from DIR + DATASETS

Patch 1.4.1 like this:

```python
# 1.4.1 Load Raw Dataset (CSV: Config-Driven, with READ_OPTS) / (PARQUET: )
print("1.4 üß© DATASET LOAD & VERSION VERIFICATION")

# Decide which dataset we‚Äôre loading (for now, hard-code TELCO)
dataset_key = "TELCO"

raw_file_name = C(f"DATASETS.{dataset_key}.RAW_FILE", None)
if raw_file_name is None:
    raise KeyError(
        f"‚ùå Missing RAW_FILE for dataset {dataset_key!r} in CONFIG['DATASETS']."
    )

RAW_DATA = RAW_DATA_DIR / raw_file_name

print(f"1.4.1) üì• Loading raw dataset from: {RAW_DATA}")

if not RAW_DATA.exists():
    raise FileNotFoundError(f"‚ùå RAW_DATA file not found at {RAW_DATA}")

# Pull CSV read options from config (READ_OPTS is optional)
READ_OPTS = C("READ_OPTS", {}) or {}

suffix = RAW_DATA.suffix.lower()

if suffix == ".csv":
    print(f"   Using READ_OPTS from config: {READ_OPTS}")
    df_raw = pd.read_csv(RAW_DATA, **READ_OPTS)
elif suffix in {".parquet", ".pq"}:
    df_raw = pd.read_parquet(RAW_DATA)
else:
    raise ValueError(f"‚ùå Unsupported file format for RAW_DATA: {suffix!r}")

n_rows, n_cols = df_raw.shape
print(f"‚úÖ Loaded dataset: {n_rows:,} rows √ó {n_cols:,} columns")
```

Key ideas in this approach:

* **Separation of concerns**:

  * 1.3.1 ‚Üí resolve **directories** from `PATHS.*`
  * 1.4.1 ‚Üí resolve **which dataset file** to load (`DATASETS.TELCO.RAW_FILE`)
* The error you got (‚Äúunsupported file format‚Äù) is now prevented because `RAW_DATA` is definitely a **file**, not a folder.

---

### 4Ô∏è‚É£ Sanity check

After you run 1.3.1 and 1.4.1 with these changes, check:

```python
print("RAW_DATA_DIR:", RAW_DATA_DIR)
print("RAW_DATA:", RAW_DATA)
print("suffix:", RAW_DATA.suffix)
df_raw.head()
```

You should see:

* `RAW_DATA_DIR` ‚Üí something like `/‚Ä¶/data/_raw`
* `RAW_DATA` ‚Üí `/‚Ä¶/data/_raw/WA_Fn-UseC_-Telco-Customer-Churn.csv`
* `suffix` ‚Üí `.csv`
* And the data printing nicely.

If you want, next step we can generalize `dataset_key` so you can switch datasets via config or CLI arg, but this gets you unblocked cleanly.

---
---

># Q: I renamed RAW_DATA_DIR to 'RAW_DATA' in the yaml. would it be better to keep it as 'RAW_DATA_DIR'?

Yeah, I‚Äôd keep it as `RAW_DATA_DIR` in the YAML (and in code) ‚Äî that‚Äôs the cleaner long-term move.

Here‚Äôs why:

### 1Ô∏è‚É£ Decide what `PATHS.*` *means*

Looking at your config:

```yaml
PATHS:
  RAW_DATA_DIR: "data/_raw/"
  PROCESSED_DIR: "data/processed/"
  ARTIFACTS: "Level_3/resources/artifacts/"
  REPORTS:   "Level_3/resources/reports/"
  FIGURES:   "Level_3/resources/figures/"
  MODELS:    "Level_3/resources/models/"
  OUTPUTS:   "Level_3/outputs/"
```

All of these are **directories**. So conceptually:

* `PATHS` = *directories*, not files.
* Datasets live under `DATASETS.*` (`RAW_FILE` etc).

That makes `RAW_DATA_DIR` the honest name: it is a directory, not a file.

If you call it just `RAW_DATA`, you introduce ambiguity:

* Is `RAW_DATA` the **folder**?
* Or the **file** (e.g. full CSV path)?
* Or later, a **table** / **view**?

Future-you will have to keep that straight in their head every time.

---

### 2Ô∏è‚É£ A naming pattern that will age well

If you stick with this pattern:

* `PATHS.RAW_DATA_DIR` ‚Üí directory
* `DATASETS.TELCO.RAW_FILE` ‚Üí filename
* Code:

  ```python
  RAW_DATA_DIR = PROJECT_ROOT / C("PATHS.RAW_DATA_DIR")
  RAW_DATA_FILE = RAW_DATA_DIR / C("DATASETS.TELCO.RAW_FILE")
  ```

‚Ä¶then your 1.4.x section reads almost self-documenting:

```python
print("1.4.1) üì• Loading raw dataset from:", RAW_DATA_FILE)
suffix = RAW_DATA_FILE.suffix.lower()
```

No guessing what‚Äôs what.

---

### 3Ô∏è‚É£ How to keep it both clean *and* backward-friendly

Given you already renamed to `RAW_DATA`, I‚Äôd do this:

**In `project_config.yaml` (preferred canonical):**

```yaml
PATHS:
  RAW_DATA_DIR: "data/_raw/"
  PROCESSED_DIR: "data/processed/"
  ...
```

**In 1.3.1, support both names just in case:**

```python
# RAW_DATA_DIR: prefer RAW_DATA_DIR, but fall back to older RAW_DATA
raw_data_rel = C("PATHS.RAW_DATA_DIR", None)
if raw_data_rel is None:
    raw_data_rel = C("PATHS.RAW_DATA", None)
if raw_data_rel is None:
    raise KeyError(
        "‚ùå Missing config for RAW_DATA directory. "
        "Tried PATHS.RAW_DATA_DIR and PATHS.RAW_DATA."
    )
RAW_DATA_DIR = PROJECT_ROOT / raw_data_rel
```

Then in 1.4.1:

```python
dataset_key = "TELCO"
raw_file_name = C(f"DATASETS.{dataset_key}.RAW_FILE")
RAW_DATA_FILE = RAW_DATA_DIR / raw_file_name
```

---

### TL;DR

* **Yes**, conceptually it‚Äôs better to keep `RAW_DATA_DIR` as the key, because `PATHS` is a set of directories.
* Use `*_DIR` for folders (`RAW_DATA_DIR`, `PROCESSED_DIR`) and `*_FILE` for concrete files (`RAW_DATA_FILE`).
* Add a tiny compatibility shim if you want to be nice to older configs, but standardize your *new* stuff on the clearer naming.
